HTML FILE 

user-analysis.html 

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site Analysis - SSN AI</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="/styles/user-analysis.css">
    <!-- Add this CSS for the PDF logo -->
    <style>
        #pdfLogo {
            display: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- ADD THIS SCRIPT BLOCK -->
    <script>
        function checkUserAccess() {
            const user = sessionStorage.getItem('ssnai_user') || localStorage.getItem('ssnai_user');
            const isAdmin = sessionStorage.getItem('ssnai_admin') ||
                localStorage.getItem('ssnai_admin') ||
                localStorage.getItem('ssnai_admin_exists');

            if (!user && !isAdmin) {
                console.warn("Unauthorized access attempt to user analysis");
                alert("User login required. Redirecting to login.");
                window.location.href = 'signup.html';
                return false;
            }

            // If it's an admin but they reached the user page, redirect to admin map
            if (isAdmin && !user) {
                console.warn("Admin accessed user analysis page - redirecting to admin map");
                window.location.href = 'map-analysis.html';
                return false;
            }

            return true;
        }
        // Run check immediately when page loads
        document.addEventListener('DOMContentLoaded', checkUserAccess);
    </script>
</head>

<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="dashboard.html" class="nav-logo">
                <i class="fas fa-map-marked-alt"></i>
                <span>SSN AI</span>
            </a>
            <div class="nav-actions">
                <button class="btn-back" onclick="window.location.href='dashboard.html'">
                    <i class="fas fa-arrow-left"></i> Back to Dashboard
                </button>
                <button class="btn-export" id="exportBtn" onclick="exportPDF()">
                    <i class="fas fa-file-pdf"></i> Export PDF
                </button>
            </div>
        </div>
    </nav>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-content">
            <img src="/Images/Real+Estate.gif" alt="Analyzing" class="loading-gif">
            <h2>Analyzing Your Location...</h2>
            <p>Please wait while we process your site analysis</p>
        </div>
    </div>

    <!-- Main Content (FULL SCREEN LAYOUT) -->
    <div id="mainContent" class="main-content" style="display: none;">

        <!-- Map Container (FULL WIDTH - NO LEFT PANEL) -->
        <div class="map-container" id="mapContainer">
            <canvas id="mapCanvas"></canvas>
        </div>

        <!-- Right Panel: Details (NO CLOSE BUTTON) -->
        <div id="rightPanel" class="right-panel">
            <div class="panel-header">
                <h3><i class="fas fa-info-circle"></i> Analysis Details</h3>
            </div>
            <div class="panel-content" id="rightPanelContent">
                <!-- ========== ADD DRAG BUTTON HERE ========== -->
                <div class="drag-control-section">
                    <h4><i class="fas fa-hand-rock"></i> Drag Mode</h4>
                    <button id="dragModeBtn" class="btn-drag-toggle" onclick="toggleDragMode()">
                        <i class="fas fa-arrows-alt"></i>
                        <span id="dragBtnText">Enable Drag Mode</span>
                    </button>
                    <div id="dragInstructions" class="drag-instructions">
                        <i class="fas fa-check-circle"></i> Drag mode enabled! Click and drag any item (logos, clusters,
                        highways, site marker) to reposition them.
                    </div>
                </div>
                <!-- ========== END DRAG BUTTON ========== -->

                <!-- ========== ADD RESIZE BUTTON HERE ========== -->
                <div class="resize-control-section">
                    <h4><i class="fas fa-expand-arrows-alt"></i> Resize Mode</h4>
                    <button id="resizeModeBtn" class="btn-resize-toggle" onclick="toggleResizeMode()">
                        <i class="fas fa-expand-alt"></i>
                        <span id="resizeBtnText">Enable Resize Mode</span>
                    </button>
                    <div id="resizeInstructions" class="resize-instructions">
                        <i class="fas fa-check-circle"></i> Resize mode enabled! Click on any item to adjust its size.
                    </div>
                </div>
                <!-- ========== END RESIZE BUTTON ========== -->

                <!-- ========== CLUSTER CONTROLS SECTION ========== -->
                <div class="cluster-controls-section">
                    <h4><i class="fas fa-shapes"></i> Size and Shape Controls</h4>
                    <div class="button-row">
                        <button id="reshapeBtn" class="btn-cluster-control btn-reshape">
                            <i class="fas fa-vector-square"></i>
                            <span>Reshape Clusters</span>
                        </button>
                        <button id="rotateBtn" class="btn-cluster-control btn-rotate">
                            <i class="fas fa-sync-alt"></i>
                            <span>Rotate Highways</span>
                        </button>
                    </div>
                </div>
                <!-- ========== END CLUSTER CONTROLS ========== -->

            </div>

            <div class="info-section">
                <h4><i class="fas fa-map-marker-alt"></i> Location</h4>
                <p id="locationInfo">Loading...</p>
            </div>
            <div class="info-section">
                <h4><i class="fas fa-circle"></i> Search Area</h4>
                <p id="searchArea">Loading...</p>
            </div>

            <!-- POI Sections -->
            <div id="poiSections"></div>

            <!-- Highway Section -->
            <div id="highwaySection"></div>
        </div>
    </div>

    <script type="module" src="/js/user-analysis.js"></script>
    <!-- Hidden logo for PDF reports -->
    <img id="pdfLogo" src="/Images/image.png" alt="Company Logo" style="display:none;">
</body>

</html>


CSS FILE


user-analysis.css

/* ==================== COMPLETE CSS REPLACEMENT ==================== */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
}

/* ==================== NAVBAR ==================== */
.navbar {
    background: linear-gradient(135deg, #8B0000, #A52A2A);
    padding: 1rem 0;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    height: 60px;
}

.nav-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 0 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.nav-logo {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 1.5rem;
    font-weight: bold;
    color: white;
    text-decoration: none;
}

.nav-actions {
    display: flex;
    gap: 1rem;
}

.btn-back,
.btn-export {
    padding: 0.5rem 1.5rem;
    border: none;
    border-radius: 25px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.btn-back {
    background: white;
    color: #8B0000;
}

.btn-back:hover {
    background: #f8f9fa;
}

.btn-export {
    background: #28a745;
    color: white;
}

.btn-export:hover {
    background: #218838;
}

/* ==================== LOADING OVERLAY ==================== */
.loading-overlay {
    position: fixed;
    top: 60px;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 999;
}

.loading-content {
    text-align: center;
    color: rgb(255, 255, 255);
}

.loading-gif {
    width: 400px;
    height: 300px;
    border-radius: 15px;
    margin-bottom: 2rem;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
}

.loading-content h2 {
    font-size: 2rem;
    margin-bottom: 1rem;
}

.loading-content p {
    font-size: 1.2rem;
    opacity: 0.8;
}

/* ==================== MAIN CONTENT (NO LEFT PANEL) ==================== */
.main-content {
    position: fixed;
    top: 60px;
    left: 0;
    right: 0;
    bottom: 0;
    display: grid;
    grid-template-columns: 1fr 400px;
}

/* ==================== RIGHT PANEL (NO CLOSE BUTTON) ==================== */
.right-panel {
    background: rgb(255, 255, 255);
    overflow-y: auto;
    box-shadow: -2px 0 20px rgba(0, 0, 0, 0.1);
    z-index: 10;
        
}

.panel-header {
    padding: 1.5rem;
    background: linear-gradient(135deg, #8B0000, #A52A2A);
    color: white;
    position: sticky;
    top: 0;
    z-index: 10;
}

.panel-header h3 {
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.panel-content {
    padding: 1.5rem;
}

.panel-content {
    padding: 1.5rem;
}

/* ========== ADD THIS NEW DRAG BUTTON SECTION ========== */
.drag-control-section {
    margin-bottom: 1.5rem;
    padding: 1.5rem;
    background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    border-radius: 10px;
    border: 2px solid #8B0000;
}

.drag-control-section h4 {
    color: #8B0000;
    margin-bottom: 1rem;
    font-size: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.btn-drag-toggle {
    width: 100%;
    background: linear-gradient(135deg, #8B0000, #A52A2A);
    color: white;
    border: none;
    padding: 0.875rem 1.5rem;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    transition: all 0.3s ease;
    font-size: 0.95rem;
}

.btn-drag-toggle:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(139, 0, 0, 0.4);
}

.btn-drag-toggle.active {
    background: linear-gradient(135deg, #28a745, #20c997);
}

.btn-drag-toggle.active:hover {
    background: linear-gradient(135deg, #218838, #1aa179);
}

.drag-instructions {
    margin-top: 0.75rem;
    padding: 0.75rem;
    background: white;
    border-radius: 6px;
    font-size: 0.85rem;
    color: #666;
    display: none;
    line-height: 1.5;
}

.drag-instructions.show {
    display: block;
}

.drag-instructions i {
    color: #28a745;
    margin-right: 0.5rem;
}

/* Drag mode cursor styles */
body.drag-mode-active {
    cursor: move !important;
}

body.drag-mode-active * {
    cursor: move !important;
}

.draggable-item {
    cursor: grab !important;
}

.draggable-item:active {
    cursor: grabbing !important;
}
/* ========== END NEW DRAG BUTTON SECTION ========== */

/* ========== RESIZE BUTTON SECTION ========== */
.resize-control-section {
    margin-bottom: 1.5rem;
    padding: 1.5rem;
    background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    border-radius: 10px;
    border: 2px solid #0066cc;
}

.resize-control-section h4 {
    color: #0066cc;
    margin-bottom: 1rem;
    font-size: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.btn-resize-toggle {
    width: 100%;
    background: linear-gradient(135deg, #0066cc, #0088ff);
    color: white;
    border: none;
    padding: 0.875rem 1.5rem;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    transition: all 0.3s ease;
    font-size: 0.95rem;
}

.btn-resize-toggle:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 102, 204, 0.4);
}

.btn-resize-toggle.active {
    background: linear-gradient(135deg, #28a745, #20c997);
}

.btn-resize-toggle.active:hover {
    background: linear-gradient(135deg, #218838, #1aa179);
}

.resize-instructions {
    margin-top: 0.75rem;
    padding: 0.75rem;
    background: white;
    border-radius: 6px;
    font-size: 0.85rem;
    color: #666;
    display: none;
    line-height: 1.5;
}

.resize-instructions.show {
    display: block;
}

.resize-instructions i {
    color: #28a745;
    margin-right: 0.5rem;
}

/* Resize mode cursor styles */
body.resize-mode-active {
    cursor: default;
}

body.resize-mode-active * {
    cursor: pointer;
}

body.resize-mode-active .right-panel,
body.resize-mode-active .right-panel * {
    cursor: default !important;
}
/* ========== END RESIZE BUTTON SECTION ========== */

/* ========== CLUSTER CONTROLS SECTION ========== */
.cluster-controls-section {
    margin-bottom: 1.5rem;
    padding: 1.5rem;
    background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    border-radius: 10px;
    border: 2px solid #6c757d;
}

.cluster-controls-section h4 {
    color: #6c757d;
    margin-bottom: 1rem;
    font-size: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.button-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.75rem;
}

.btn-cluster-control {
    background: linear-gradient(135deg, #6c757d, #868e96);
    color: white;
    border: none;
    padding: 0.75rem 1rem;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    transition: all 0.3s ease;
    font-size: 0.85rem;
    min-height: 70px;
}

.btn-cluster-control i {
    font-size: 1.2rem;
}

.btn-cluster-control span {
    text-align: center;
    line-height: 1.2;
}

.btn-reshape {
    background: linear-gradient(135deg, #17a2b8, #20c997);
}

.btn-reshape:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(23, 162, 184, 0.4);
    background: linear-gradient(135deg, #138496, #1aa179);
}

.btn-rotate {
    background: linear-gradient(135deg, #6f42c1, #9b59b6);
}

.btn-rotate:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(111, 66, 193, 0.4);
    background: linear-gradient(135deg, #5a32a3, #8e44ad);
}

.btn-cluster-control:active {
    transform: translateY(0);
}

.btn-cluster-control.active {
    background: linear-gradient(135deg, #28a745, #20c997);
    box-shadow: 0 0 15px rgba(40, 167, 69, 0.5);
}

.btn-cluster-control:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.btn-cluster-control:disabled:hover {
    transform: none;
    box-shadow: none;
}

/* Responsive for smaller panels */
@media (max-width: 1400px) {
    .button-row {
        gap: 0.5rem;
    }
    
    .btn-cluster-control {
        padding: 0.6rem 0.8rem;
        font-size: 0.8rem;
        min-height: 65px;
    }
    
    .btn-cluster-control i {
        font-size: 1rem;
    }
}

@media (max-width: 1200px) {
    .button-row {
        grid-template-columns: 1fr;
        gap: 0.5rem;
    }
    
    .btn-cluster-control {
        min-height: 60px;
    }
}
/* ========== END CLUSTER CONTROLS SECTION ========== */

.info-section {
    margin-bottom: 1.5rem;
    padding: 1.5rem;
    background: #f8f8f8;
    border-radius: 10px;
    border-left: 4px solid #8B0000;
}

.info-section h4 {
    color: #8B0000;
    margin-bottom: 0.75rem;
    font-size: 1rem;
}

.coord-item {
    padding: 0.5rem;
    background: rgb(239, 240, 241);
    margin-bottom: 0.5rem;
    border-radius: 5px;
    font-size: 0.85rem;
}

/* ==================== MAP CONTAINER (FULL SCREEN - NO ZOOM BUTTONS) ==================== */
.map-container {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #f0f0f0;
    display: flex;
    align-items: center;
    justify-content: center;
}

#mapCanvas {
    display: block;
    cursor: default;
    width: 100%;
    height: 100%;
    object-fit: contain;
}

/* ==================== POI SECTIONS ==================== */
.poi-category-section {
    margin-bottom: 1.5rem;
    background: white;
    border: 2px solid #e9ecef;
    border-radius: 10px;
    overflow: hidden;
}

.poi-category-section h4 {
    background: #8B0000;
    color: white;
    padding: 1rem;
    margin: 0;
    font-size: 1rem;
}

.poi-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 250px;
    overflow-y: auto;
}

.poi-list li {
    padding: 0.75rem;
    border-bottom: 1px solid #e9ecef;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.poi-list li:hover {
    background: #f8f9fa;
}

.poi-list li:last-child {
    border-bottom: none;
}

.poi-logo {
    width: 24px;
    height: 24px;
    object-fit: contain;
    border-radius: 3px;
}

/* ==================== HIGHWAY SECTION ==================== */
.highway-section {
    margin-top: 1.5rem;
    background: #f0f8ff;
    border: 2px solid #0066cc;
    border-radius: 10px;
    overflow: hidden;
}

.highway-section h4 {
    background: #0066cc;
    color: white;
    padding: 1rem;
    margin: 0;
    font-size: 1rem;
}

.route-badge {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    border-radius: 5px;
    font-size: 0.8rem;
    font-weight: bold;
    color: white;
    margin-right: 0.5rem;
}

/* ==================== SCROLLBAR ==================== */
.panel-content::-webkit-scrollbar,
.poi-list::-webkit-scrollbar {
    width: 8px;
}

.panel-content::-webkit-scrollbar-track,
.poi-list::-webkit-scrollbar-track {
    background: #f1f1f1;
}

.panel-content::-webkit-scrollbar-thumb,
.poi-list::-webkit-scrollbar-thumb {
    background: #8B0000;
    border-radius: 4px;
}

.panel-content::-webkit-scrollbar-thumb:hover,
.poi-list::-webkit-scrollbar-thumb:hover {
    background: #6B0000;
}

/* ==================== RESPONSIVE ==================== */
@media (max-width: 1200px) {
    .main-content {
        grid-template-columns: 1fr 350px;
    }
}

@media (max-width: 768px) {
    .main-content {
        grid-template-columns: 1fr;
    }

    .right-panel {
        position: absolute;
        top: 0;
        bottom: 0;
        right: 0;
        width: 300px;
        z-index: 100;
    }
}





JAVASCRIPT FILES


user-analysis.js

// ==================== USER ANALYSIS - MAIN ENTRY POINT ====================
// This file imports and orchestrates all modular components

// Import constants and configuration
import { LOGODEV_API_KEY, osmTags, categoryIcons, FAMOUS_LOCATIONS, GRID_ROWS, GRID_COLS } from './user-analysis/constants.js';

// Import state management
import * as State from './user-analysis/state.js';

// Import utilities
import * as Utilities from './user-analysis/utilities.js';

// Import coordinate functions
import * as Coordinates from './user-analysis/coordinates.js';

// Import API fetching
import * as ApiFetching from './user-analysis/api-fetching.js';

// Import highway fetching
import * as HighwayFetching from './user-analysis/highway-fetching.js';

// Import clustering
import * as Clustering from './user-analysis/clustering.js';

// Import canvas setup
import * as CanvasSetup from './user-analysis/canvas-setup.js';

// Import map tiles
import * as MapTiles from './user-analysis/map-tiles.js';

// Import rendering
import * as Rendering from './user-analysis/rendering.js';

// Import cluster rendering
import * as ClusterRendering from './user-analysis/cluster-rendering.js';

// Import drag functionality
import * as DragFunctionality from './user-analysis/drag-functionality.js';

// ==================== ADD RESIZE IMPORT HERE ====================
// Import resize functionality
import * as ResizeFunctionality from './user-analysis/resize-functionality.js';
// ==================== END RESIZE IMPORT ====================


// Import UI updates
import * as UiUpdates from './user-analysis/ui-updates.js';

// Import PDF export
import * as PdfExport from './user-analysis/pdf-export.js';

// Import main rendering
import * as MainRender from './user-analysis/main-render.js';

// Import initialization
import * as Initialization from './user-analysis/initialization.js';

// Import diagnostics
import * as Diagnostics from './user-analysis/diagnostics.js';

// ==================== INITIALIZATION ====================

console.log('✓ user-analysis.js loaded successfully');
console.log('✓ All modules imported');

// Setup global functions
UiUpdates.setupGlobalToggleFunctions();
PdfExport.setupGlobalExportFunction();
Diagnostics.setupGlobalDiagnostics();
Diagnostics.setupGlobalPerformanceMonitor();

// Make drag toggle globally available
window.toggleDragMode = DragFunctionality.toggleDragMode;

// ==================== ADD RESIZE SETUP HERE ====================
// Make resize toggle globally available
window.toggleResizeMode = ResizeFunctionality.toggleResizeMode;
ResizeFunctionality.setupGlobalResizeFunctions();
// ==================== END RESIZE SETUP ====================

// Setup handlers
Initialization.setupResizeHandler();
Initialization.setupErrorHandlers();
Initialization.setupCleanupHandlers();

// Initialize on window load
window.addEventListener('load', async function() {
    console.log('Window loaded, starting initialization...');
    
    // Setup canvas click listener
    const canvas = document.getElementById('mapCanvas');
    if (canvas) {
        canvas.addEventListener('click', DragFunctionality.handleCanvasClick);
    }
    
    // Start analysis
    await Initialization.initializeAnalysis();
});

// ==================== EXPORTED API ====================
// Export main functions for external use if needed
export {
    // State
    State,
    // Utilities
    Utilities,
    // Coordinates
    Coordinates,
    // API
    ApiFetching,
    HighwayFetching,
    // Clustering
    Clustering,
    // Canvas
    CanvasSetup,
    MapTiles,
    // Rendering
    Rendering,
    ClusterRendering,
    // Interactions
    DragFunctionality,
    ResizeFunctionality,  // ⭐ ADD THIS LINE
    // UI
    UiUpdates,
    PdfExport,
    // Main
    MainRender,
    Initialization,
    // Debug
    Diagnostics
};
console.log('✓ All systems ready');




user-analysis folder FILES


js/user-analysis/api-fetching.js 






// ==================== API FETCHING AND DATA PROCESSING ====================

import { 
    osmTags, 
    FAMOUS_LOCATIONS, 
    LOGODEV_API_KEY 
} from './constants.js';
import { 
    selectedSiteLocation, 
    analysisParams,
    allPOIsDataByCategory,
    setAllPOIsDataByCategory,
    selectedPOIs,
    setSelectedPOIs,
    highwayData,
    setHighwayData,
    selectedHighways,
    setSelectedHighways
} from './state.js';
import { calculateDistance, delay, formatAddress } from './utilities.js';

/**
 * Fetch with retry logic for failed requests
 */
export async function fetchWithRetry(url, options, retries = 3, delayMs = 3000) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url, options);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                throw new Error('Response is not JSON');
            }

            return await response.json();
        } catch (error) {
            console.warn(`Attempt ${i + 1} failed:`, error.message);

            if (i === retries - 1) {
                throw error;
            }

            await new Promise(resolve => setTimeout(resolve, delayMs * (i + 1)));
        }
    }
}

/**
 * Fetch POIs for a specific category from Overpass API
 */
export async function fetchPOIsForCategory(category) {
    const tag = osmTags[category];
    const radiusMeters = analysisParams.radius * 1609.34;

    let query;
    if (category === 'popularLocations') {
        query = `[out:json][timeout:15];(
            node["tourism"="attraction"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
            way["tourism"="attraction"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
            node["leisure"="park"]["name"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
            way["leisure"="park"]["name"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
            node["shop"="department_store"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
            way["shop"="department_store"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
        );out center;`;
    } else if (category === 'school') {
        query = `[out:json][timeout:15];(
            node["amenity"="school"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
            way["amenity"="school"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
            node["amenity"="university"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
            way["amenity"="university"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
        );out center;`;
    } else {
        const [key, value] = tag.split('=');
        query = `[out:json][timeout:15];(
            node["${key}"="${value}"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
            way["${key}"="${value}"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
        );out center;`;
    }

    try {
        const data = await fetchWithRetry('https://overpass-api.de/api/interpreter', {
            method: 'POST',
            body: query,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        });

        console.log(`✓ ${category}: received ${data.elements ? data.elements.length : 0} results`);
        let processed = processPOIData(data.elements || [], category);
        processed = limitDuplicatePOIs(processed, 3);
        return processed;
    } catch (error) {
        console.error(`✗ Failed to fetch ${category} after retries:`, error.message);
        return [];
    }
}

/**
 * Process raw POI data from Overpass API
 */
export function processPOIData(elements, category) {
    return elements.map(el => {
        const pos = el.lat ? { lat: el.lat, lng: el.lon } : { lat: el.center.lat, lng: el.center.lon };
        const tags = el.tags || {};
        const name = tags.name || category.replace(/_/g, ' ').toUpperCase();
        const distance = calculateDistance(selectedSiteLocation.lat, selectedSiteLocation.lng, pos.lat, pos.lng);
        const distanceMiles = distance / 1.60934;

        return {
            id: el.id,
            name,
            lat: pos.lat,
            lng: pos.lng,
            website: tags.website || tags['contact:website'],
            category,
            distanceMiles,
            logoUrl: null,
            coordinates: `${pos.lat.toFixed(6)}, ${pos.lng.toFixed(6)}`,
            address: formatAddress(tags),
            postalCode: tags['addr:postcode'] || 'N/A',
            pixelX: 0,
            pixelY: 0,
            logoSize: 40
        };
    }).sort((a, b) => a.distanceMiles - b.distanceMiles);
}

/**
 * Limit duplicate POIs with same name
 */
export function limitDuplicatePOIs(pois, maxDuplicates = 3) {
    const nameCounts = {};
    const filteredPOIs = [];

    for (const poi of pois) {
        const baseName = poi.name
            .replace(/\s+(#\d+|Store|Location|Branch)/gi, '')
            .trim()
            .toLowerCase();

        if (!nameCounts[baseName]) {
            nameCounts[baseName] = 0;
        }

        if (nameCounts[baseName] < maxDuplicates) {
            filteredPOIs.push(poi);
            nameCounts[baseName]++;
        } else {
            console.log(`Skipping duplicate: ${poi.name} (already have ${maxDuplicates})`);
        }
    }

    console.log(`Filtered ${pois.length} POIs down to ${filteredPOIs.length} (max ${maxDuplicates} per name)`);
    return filteredPOIs;
}

/**
 * Fetch logo from Logo.dev API
 */
export async function fetchLogoFromLogoDev(website) {
    if (!website) return null;
    try {
        let domain = website.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0];
        const response = await fetch(`https://img.logo.dev/${domain}?token=${LOGODEV_API_KEY}&size=200`);
        if (response.ok) {
            const blob = await response.blob();
            if (blob.size < 500) return null;
            return response.url;
        }
    } catch (error) {
        console.log('Logo fetch failed');
    }
    return null;
}

/**
 * Enrich single POI with logo
 */
export async function enrichPOIWithLogo(poi) {
    if (poi.website) {
        const logoUrl = await fetchLogoFromLogoDev(poi.website);
        if (logoUrl) {
            poi.logoUrl = logoUrl;
            return true;
        }
    }
    return false;
}

/**
 * Enrich multiple POIs with logos
 */
export async function enrichPOIsWithLogos(pois) {
    const promises = pois.map(poi => enrichPOIWithLogo(poi));
    await Promise.all(promises);
}

/**
 * Prioritize famous locations in POI list
 */
export async function prioritizeFamousLocations(pois, category) {
    if (!FAMOUS_LOCATIONS[category]) return pois;

    const famousNames = FAMOUS_LOCATIONS[category].map(name => name.toLowerCase());
    const famousPOIs = [];
    const regularPOIs = [];

    for (const poi of pois) {
        const poiName = poi.name.toLowerCase();
        const isFamous = famousNames.some(famousName =>
            poiName.includes(famousName.toLowerCase()) ||
            famousName.toLowerCase().includes(poiName)
        );

        if (isFamous) {
            famousPOIs.push({ ...poi, isFamous: true });
        } else {
            regularPOIs.push({ ...poi, isFamous: false });
        }
    }

    await enrichPOIsWithLogos(famousPOIs);
    await enrichPOIsWithLogos(regularPOIs);

    const famousWithLogos = famousPOIs.filter(poi => poi.logoUrl);
    const regularWithLogos = regularPOIs.filter(poi => poi.logoUrl);
    const famousWithoutLogos = famousPOIs.filter(poi => !poi.logoUrl);

    if (famousWithLogos.length > 0) {
        return [...famousWithLogos, ...regularWithLogos, ...famousWithoutLogos];
    } else {
        return [...regularWithLogos, ...famousWithoutLogos];
    }
}

/**
 * Filter to only famous locations with logos
 */
export async function filterOnlyFamousLocations(pois, category) {
    if (!FAMOUS_LOCATIONS[category]) return pois;

    const famousNames = FAMOUS_LOCATIONS[category].map(name => name.toLowerCase());

    console.log(`Attempting to fetch logos for ${pois.length} ${category} POIs...`);
    await enrichPOIsWithLogos(pois);

    const famousWithLogos = [];
    const famousWithoutLogos = [];
    const regularWithLogos = [];

    pois.forEach(poi => {
        const poiName = poi.name.toLowerCase();
        const isFamous = famousNames.some(famousName =>
            poiName.includes(famousName.toLowerCase()) ||
            famousName.toLowerCase().includes(poiName)
        );

        if (isFamous) {
            if (poi.logoUrl) {
                famousWithLogos.push({ ...poi, isFamous: true });
            } else {
                famousWithoutLogos.push({ ...poi, isFamous: true });
            }
        } else if (poi.logoUrl) {
            regularWithLogos.push({ ...poi, isFamous: false });
        }
    });

    console.log(`${category} breakdown: ${famousWithLogos.length} famous with logos, ${regularWithLogos.length} regular with logos, ${famousWithoutLogos.length} famous without logos`);

    return [...famousWithLogos, ...regularWithLogos, ...famousWithoutLogos];
}

/**
 * Fetch all POIs for all selected categories
 */
export async function fetchAllPOIs() {
    const categories = Object.keys(analysisParams.pois);

    for (let i = 0; i < categories.length; i++) {
        const cat = categories[i];
        console.log(`\nFetching category ${i + 1}/${categories.length}: ${cat}`);

        let pois = await fetchPOIsForCategory(cat);

        if (cat === 'popularLocations') {
            pois = await filterOnlyFamousLocations(pois, cat);
        } else {
            pois = await prioritizeFamousLocations(pois, cat);
        }

        pois = pois.slice(0, analysisParams.pois[cat]);
        allPOIsDataByCategory[cat] = pois;

        if (!selectedPOIs[cat]) selectedPOIs[cat] = {};
        pois.forEach((poi, idx) => {
            selectedPOIs[cat][idx] = true;
        });

        if (i < categories.length - 1) {
            console.log('Waiting 4 seconds before next request...');
            await delay(4000);
        }
    }

    console.log('\n✓ All POI categories fetched');
    console.log('Summary:', Object.entries(allPOIsDataByCategory).map(
        ([cat, pois]) => `${cat}: ${pois.length}`
    ).join(', '));
}











js/user-analysis/canvas-setup.js 




// ==================== CANVAS SETUP AND MANAGEMENT ====================

import { 
    mapCanvas, 
    ctx,
    MAP_WIDTH,
    MAP_HEIGHT,
    setMapCanvas, 
    setMapContext, 
    setMapDimensions 
} from './state.js';
import { polyfillRoundRect } from './utilities.js';

/**
 * Update canvas size based on container
 */
export function updateCanvasSize() {
    const container = document.getElementById('mapContainer');

    // Use full container size
    const width = container.clientWidth;
    const height = container.clientHeight;

    setMapDimensions(width, height);

    if (mapCanvas) {
        mapCanvas.width = width;
        mapCanvas.height = height;
    }

    console.log(`Canvas size: ${width} x ${height}`);
}

/**
 * Set canvas quality settings for high-quality rendering
 */
export function setCanvasQuality() {
    if (!ctx) return;

    // Enable high-quality rendering
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    // Set text rendering quality
    ctx.textRendering = 'optimizeLegibility';

    console.log('✓ Canvas quality settings applied');
}

/**
 * Initialize canvas with quality settings
 */
export function initializeCanvas() {
    const canvas = document.getElementById('mapCanvas');
    if (!canvas) {
        console.error('Canvas element not found');
        return false;
    }

    const context = canvas.getContext('2d', {
        alpha: false,
        desynchronized: true
    });

    if (!context) {
        console.error('Could not get 2D context');
        return false;
    }

    setMapCanvas(canvas);
    setMapContext(context);

    console.log('✓ Canvas initialized successfully');

    // Apply polyfills
    polyfillRoundRect();

    // Set canvas size
    updateCanvasSize();

    // Apply quality settings
    setCanvasQuality();

    return true;
}

/**
 * Clear the entire canvas
 */
export function clearCanvas() {
    if (ctx && mapCanvas) {
        ctx.clearRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
    }
}

/**
 * Update canvas size with quality settings
 */
export function updateCanvasSizeWithQuality() {
    updateCanvasSize();
    setCanvasQuality();
}









js/user-analysis/cluster-rendering.js 








// ==================== CLUSTER RENDERING ====================

import { ctx, poiClusters, MAP_WIDTH, MAP_HEIGHT } from './state.js';
import { isWithinMapBounds, loadImage } from './utilities.js';
import { drawStarIconSmall, loadImageCached } from './rendering.js';

/**
 * Draw all clusters with enhanced styling
 */
export function drawClustersEnhanced() {
    poiClusters.forEach(cluster => {
        let clusterX = cluster.clusterX;
        let clusterY = cluster.clusterY;

        if (cluster.isDragged) {
            clusterX = cluster.draggedX;
            clusterY = cluster.draggedY;
        }

        // Only draw if cluster is within bounds
        if (!isWithinMapBounds(clusterX, clusterY, MAP_WIDTH, MAP_HEIGHT)) return;

        // Draw small white circle at mean position
        if (isWithinMapBounds(cluster.meanX, cluster.meanY, MAP_WIDTH, MAP_HEIGHT)) {
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cluster.meanX, cluster.meanY, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        // Draw arrow from mean point to cluster
        drawClusterArrowWhiteEnhanced(cluster.meanX, cluster.meanY, clusterX, clusterY);

        // Draw cluster box
        const originalClusterX = cluster.clusterX;
        const originalClusterY = cluster.clusterY;

        cluster.clusterX = clusterX;
        cluster.clusterY = clusterY;

        drawClusterBoxEnhanced(cluster);

        // Restore original for next time (unless permanently dragged)
        if (!cluster.isDragged) {
            cluster.clusterX = originalClusterX;
            cluster.clusterY = originalClusterY;
        }
    });
}

/**
 * Draw arrow from mean point to cluster
 */
export function drawClusterArrowWhiteEnhanced(fromX, fromY, toX, toY) {
    if (!isWithinMapBounds(fromX, fromY, MAP_WIDTH, MAP_HEIGHT) || 
        !isWithinMapBounds(toX, toY, MAP_WIDTH, MAP_HEIGHT)) return;

    // Draw red circle at mean position
    ctx.fillStyle = '#FF0000';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(fromX, fromY, 8, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();

    // Draw bold red line to cluster
    ctx.strokeStyle = '#FF0000';
    ctx.lineWidth = 6;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();

    // Draw red arrowhead
    const angle = Math.atan2(toY - fromY, toX - fromX);
    const arrowSize = 12;

    ctx.fillStyle = '#FF0000';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(
        toX - arrowSize * Math.cos(angle - Math.PI / 6),
        toY - arrowSize * Math.sin(angle - Math.PI / 6)
    );
    ctx.lineTo(
        toX - arrowSize * Math.cos(angle + Math.PI / 6),
        toY - arrowSize * Math.sin(angle + Math.PI / 6)
    );
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
}

/**
 * Draw cluster box with logos
 */
export function drawClusterBoxEnhanced(cluster) {
    const x = cluster.clusterX;
    const y = cluster.clusterY;
    
    // Use resized size if available, otherwise default
    const size = cluster.size || 80;

    const poisCount = cluster.pois.length;
    
    // ⭐ CHANGED: Better scaling for large clusters
    const cols = Math.ceil(Math.sqrt(poisCount));
    const rows = Math.ceil(poisCount / cols);  // ⭐ KEEP THIS LINE
    const maxLogoSize = Math.floor((size - 20) / (cols + 0.5));  // Dynamic calculation
    const logoSize = Math.max(25, Math.min(maxLogoSize, 60));  // Min 25px, Max 60px
    
    const padding = 12;


    const boxWidth = (logoSize * cols) + (padding * (cols + 1));
    const boxHeight = (logoSize * rows) + (padding * (rows + 1));

    // Draw white rounded rectangle with shadow
    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;

    ctx.fillStyle = 'white';
    ctx.strokeStyle = '#8B0000';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect(
        x - boxWidth / 2,
        y - boxHeight / 2,
        boxWidth,
        boxHeight,
        10
    );
    ctx.fill();
    ctx.stroke();

    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // Draw logos in grid
    cluster.pois.forEach((poiData, i) => {
        const row = Math.floor(i / cols);
        const col = i % cols;

        const logoX = x - boxWidth / 2 + padding + (col * (logoSize + padding)) + logoSize / 2;
        const logoY = y - boxHeight / 2 + padding + (row * (logoSize + padding)) + logoSize / 2;

        const poi = poiData.poi;

        if (poi.logoUrl) {
            loadImageCached(poi.logoUrl).then(img => {
                // Calculate aspect ratio to maintain original shape
                const imgAspect = img.width / img.height;
                let drawWidth = logoSize;
                let drawHeight = logoSize;
                
                if (imgAspect > 1) {
                    drawHeight = logoSize / imgAspect;
                } else {
                    drawWidth = logoSize * imgAspect;
                }

                // Draw logo in original aspect ratio with margin
                const margin = 2;
                ctx.drawImage(
                    img, 
                    logoX - (drawWidth - margin) / 2, 
                    logoY - (drawHeight - margin) / 2, 
                    drawWidth - margin, 
                    drawHeight - margin
                );

                // Add border
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 2;
                ctx.strokeRect(logoX - drawWidth / 2, logoY - drawHeight / 2, drawWidth, drawHeight);
            }).catch(() => {
                if (poi.category === 'popularLocations') {
                    drawStarIconSmall(logoX, logoY, logoSize);
                }
            });
        } else if (poi.category === 'popularLocations') {
            drawStarIconSmall(logoX, logoY, logoSize);
        }
    });
}

/**
 * Draw basic clusters
 */
export function drawClusters() {
    poiClusters.forEach(cluster => {
        // Draw small white circle at mean position
        ctx.fillStyle = 'white';
        ctx.strokeStyle = '#8B0000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cluster.meanX, cluster.meanY, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();

        // Draw arrow from mean point to cluster
        drawClusterArrowWhite(cluster.meanX, cluster.meanY, cluster.clusterX, cluster.clusterY);

        // Draw cluster box
        drawClusterBox(cluster);
    });
}

/**
 * Draw cluster arrow (basic version)
 */
export function drawClusterArrowWhite(fromX, fromY, toX, toY) {
    // Draw red circle at mean position
    ctx.fillStyle = '#FF0000';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(fromX, fromY, 8, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();

    // Draw bold red line
    ctx.strokeStyle = '#FF0000';
    ctx.lineWidth = 6;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();

    // Draw white arrowhead
    const angle = Math.atan2(toY - fromY, toX - fromX);
    const arrowSize = 12;

    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(
        toX - arrowSize * Math.cos(angle - Math.PI / 6),
        toY - arrowSize * Math.sin(angle - Math.PI / 6)
    );
    ctx.lineTo(
        toX - arrowSize * Math.cos(angle + Math.PI / 6),
        toY - arrowSize * Math.sin(angle + Math.PI / 6)
    );
    ctx.closePath();
    ctx.fill();
}

/**
 * Draw cluster box (basic version)
 */
export function drawClusterBox(cluster) {
    let x = cluster.clusterX;
    let y = cluster.clusterY;

    if (cluster.isDragged) {
        x = cluster.draggedX;
        y = cluster.draggedY;
    }

    const size = cluster.size;
    const poisCount = cluster.pois.length;
    const logoSize = Math.min(35, size / (Math.ceil(Math.sqrt(poisCount)) + 1));
    const padding = 12;

    const cols = Math.ceil(Math.sqrt(poisCount));
    const rows = Math.ceil(poisCount / cols);

    const boxWidth = (logoSize * cols) + (padding * (cols + 1));
    const boxHeight = (logoSize * rows) + (padding * (rows + 1));

    // Draw white rounded rectangle with shadow
    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;

    ctx.fillStyle = 'white';
    ctx.strokeStyle = '#8B0000';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect(
        x - boxWidth / 2,
        y - boxHeight / 2,
        boxWidth,
        boxHeight,
        10
    );
    ctx.fill();
    ctx.stroke();

    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // Draw logos
    cluster.pois.forEach((poiData, i) => {
        const row = Math.floor(i / cols);
        const col = i % cols;

        const logoX = x - boxWidth / 2 + padding + (col * (logoSize + padding)) + logoSize / 2;
        const logoY = y - boxHeight / 2 + padding + (row * (logoSize + padding)) + logoSize / 2;

        const poi = poiData.poi;

        if (poi.logoUrl) {
                loadImageCached(poi.logoUrl).then(img => {
                    // Calculate aspect ratio to maintain original shape
                    const imgAspect = img.width / img.height;
                    let drawWidth = logoSize;
                    let drawHeight = logoSize;
                    
                    if (imgAspect > 1) {
                        drawHeight = logoSize / imgAspect;
                    } else {
                        drawWidth = logoSize * imgAspect;
                    }

                     // Draw logo in original aspect ratio with margin
                    const margin = 2;
                    ctx.drawImage(
                        img, 
                        logoX - (drawWidth - margin) / 2, 
                        logoY - (drawHeight - margin) / 2, 
                        drawWidth - margin, 
                        drawHeight - margin
                    );

                    // Add border
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(logoX - drawWidth / 2, logoY - drawHeight / 2, drawWidth, drawHeight);
                }).catch(() => {
                if (poi.category === 'popularLocations') {
                    drawStarIconSmall(logoX, logoY, logoSize);
                }
            });
        } else if (poi.category === 'popularLocations') {
            drawStarIconSmall(logoX, logoY, logoSize);
        }
    });
}





js/user-analysis/clustering.js 




// ==================== POI CLUSTERING LOGIC ====================

import { 
    MAP_WIDTH, 
    MAP_HEIGHT, 
    allPOIsDataByCategory, 
    selectedPOIs,
    poiClusters,
    setPOIClusters,
    highwayData
} from './state.js';
import { GRID_ROWS, GRID_COLS } from './constants.js';

/**
 * Create POI clusters using 5x5 grid system
 */
export function createPOIClusters() {
    const clusters = [];
    const cellWidth = MAP_WIDTH / GRID_COLS;
    const cellHeight = MAP_HEIGHT / GRID_ROWS;

    console.log(`Creating ${GRID_ROWS}x${GRID_COLS} grid with cell size: ${cellWidth.toFixed(2)}x${cellHeight.toFixed(2)}`);

    const gridCells = [];
    for (let row = 0; row < GRID_ROWS; row++) {
        for (let col = 0; col < GRID_COLS; col++) {
            gridCells.push({
                row,
                col,
                pois: [],
                x: col * cellWidth,
                y: row * cellHeight,
                width: cellWidth,
                height: cellHeight
            });
        }
    }

    // Assign POIs to grid cells
    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        for (let idx = 0; idx < pois.length; idx++) {
            if (!selectedPOIs[category] || !selectedPOIs[category][idx]) continue;

            const poi = pois[idx];

            const col = Math.floor(poi.pixelX / cellWidth);
            const row = Math.floor(poi.pixelY / cellHeight);
            const cellIndex = row * GRID_COLS + col;

            if (cellIndex >= 0 && cellIndex < gridCells.length) {
                gridCells[cellIndex].pois.push({ poi, category, idx });
            }
        }
    }

    // Create clusters from cells with 2+ POIs
    gridCells.forEach((cell, cellIndex) => {
        if (cell.pois.length >= 2) {
            const meanX = cell.pois.reduce((sum, p) => sum + p.poi.pixelX, 0) / cell.pois.length;
            const meanY = cell.pois.reduce((sum, p) => sum + p.poi.pixelY, 0) / cell.pois.length;

            // Position cluster outside the mean point
            const offsetDistance = 80;
            const angle = Math.atan2(meanY - MAP_HEIGHT / 2, meanX - MAP_WIDTH / 2);

            const cluster = {
                id: `cluster_${cellIndex}`,
                pois: cell.pois,
                meanX: meanX,
                meanY: meanY,
                clusterX: meanX + Math.cos(angle) * offsetDistance,
                clusterY: meanY + Math.sin(angle) * offsetDistance,
                size: 80,
                cellRow: cell.row,
                cellCol: cell.col
            };

            // Adjust for overlaps with highways
            let adjusted = adjustForOverlaps(cluster);
            cluster.clusterX = adjusted.x;
            cluster.clusterY = adjusted.y;

            clusters.push(cluster);
        }
    });

    setPOIClusters(clusters);
    console.log(`✓ Created ${clusters.length} clusters from ${GRID_ROWS}x${GRID_COLS} grid`);
}

/**
 * Adjust cluster position to avoid overlaps with highways
 */
export function adjustForOverlaps(cluster) {
    // Check if cluster overlaps with highways
    for (const hw of highwayData) {
        const dist = Math.sqrt(
            Math.pow(cluster.clusterX - hw.pixelX, 2) +
            Math.pow(cluster.clusterY - hw.pixelY, 2)
        );

        if (dist < 100) {
            // Move cluster away from highway
            const angle = Math.atan2(cluster.clusterY - hw.pixelY, cluster.clusterX - hw.pixelX);
            return {
                x: hw.pixelX + Math.cos(angle) * 120,
                y: hw.pixelY + Math.sin(angle) * 120
            };
        }
    }

    return { x: cluster.clusterX, y: cluster.clusterY };
}

/**
 * Optimize cluster positions to avoid overlaps
 */
export function optimizeClusterPositions() {
    const MIN_DISTANCE = 100;

    poiClusters.forEach((cluster, index) => {
        let adjusted = true;
        let attempts = 0;
        const MAX_ATTEMPTS = 50;

        while (adjusted && attempts < MAX_ATTEMPTS) {
            adjusted = false;
            attempts++;

            // Check distance from highways
            for (const hw of highwayData) {
                const dist = Math.sqrt(
                    Math.pow(cluster.clusterX - hw.pixelX, 2) +
                    Math.pow(cluster.clusterY - hw.pixelY, 2)
                );

                if (dist < MIN_DISTANCE) {
                    const angle = Math.atan2(cluster.clusterY - hw.pixelY, cluster.clusterX - hw.pixelX);
                    cluster.clusterX = hw.pixelX + Math.cos(angle) * (MIN_DISTANCE + 20);
                    cluster.clusterY = hw.pixelY + Math.sin(angle) * (MIN_DISTANCE + 20);
                    adjusted = true;
                    break;
                }
            }

            if (adjusted) continue;

            // Check distance from other clusters
            for (let j = 0; j < poiClusters.length; j++) {
                if (j === index) continue;

                const otherCluster = poiClusters[j];
                const dist = Math.sqrt(
                    Math.pow(cluster.clusterX - otherCluster.clusterX, 2) +
                    Math.pow(cluster.clusterY - otherCluster.clusterY, 2)
                );

                if (dist < MIN_DISTANCE) {
                    const angle = Math.atan2(
                        cluster.clusterY - otherCluster.clusterY,
                        cluster.clusterX - otherCluster.clusterX
                    );
                    cluster.clusterX = otherCluster.clusterX + Math.cos(angle) * (MIN_DISTANCE + 20);
                    cluster.clusterY = otherCluster.clusterY + Math.sin(angle) * (MIN_DISTANCE + 20);
                    adjusted = true;
                    break;
                }
            }

            // Ensure cluster stays within map bounds
            const clusterRadius = cluster.size / 2;
            if (cluster.clusterX - clusterRadius < 0) cluster.clusterX = clusterRadius;
            if (cluster.clusterX + clusterRadius > MAP_WIDTH) cluster.clusterX = MAP_WIDTH - clusterRadius;
            if (cluster.clusterY - clusterRadius < 0) cluster.clusterY = clusterRadius;
            if (cluster.clusterY + clusterRadius > MAP_HEIGHT) cluster.clusterY = MAP_HEIGHT - clusterRadius;
        }
    });
}

/**
 * Check collision with highways for POI positioning
 */
export function checkCollisionWithHighways(x, y, radius) {
    // Check if a point collides with any highway
    for (const hw of highwayData) {
        const dist = Math.sqrt(
            Math.pow(x - hw.pixelX, 2) +
            Math.pow(y - hw.pixelY, 2)
        );

        if (dist < (radius + 60)) {
            return { collides: true, highway: hw, distance: dist };
        }
    }

    // Check collision with site marker
    if (window.siteMarkerPosition) {
        const dist = Math.sqrt(
            Math.pow(x - window.siteMarkerPosition.x, 2) +
            Math.pow(y - window.siteMarkerPosition.y, 2)
        );

        if (dist < (radius + window.siteMarkerPosition.radius + 40)) {
            return { collides: true, siteMarker: true, distance: dist };
        }
    }

    return { collides: false };
}

/**
 * Find safe position for POI to avoid collisions
 */
export function findSafePosition(originalX, originalY, radius, maxAttempts = 12) {
    const angleStep = (Math.PI * 2) / maxAttempts;
    const distances = [100, 120, 140, 160];

    for (const distance of distances) {
        for (let i = 0; i < maxAttempts; i++) {
            const angle = i * angleStep;
            const newX = originalX + Math.cos(angle) * distance;
            const newY = originalY + Math.sin(angle) * distance;

            // Check if within bounds
            if (newX < radius || newX > MAP_WIDTH - radius ||
                newY < radius || newY > MAP_HEIGHT - radius) {
                continue;
            }

            // Check if safe from collisions
            const collision = checkCollisionWithHighways(newX, newY, radius);
            if (!collision.collides) {
                return { x: newX, y: newY, adjusted: true };
            }
        }
    }

    return { x: originalX, y: originalY, adjusted: false };
}

















js/user-analysis/constants.js




// ==================== CONSTANTS AND CONFIGURATION ====================

export const LOGODEV_API_KEY = 'pk_Mugixd0DTQO4N80QR6b0_g';

export const osmTags = {
    popularLocations: 'tourism=attraction|amenity=community_centre|leisure=park|shop=department_store',
    school: "amenity=school",
    hospital: "amenity=hospital",
    fast_food: "amenity=fast_food",
    supermarket: "shop=supermarket",
    shopping_mall: "shop=mall",
    coffee_shop: "amenity=cafe"
};

export const categoryIcons = {
    popularLocations: "⭐",
    school: "🏫",
    hospital: "🏥",
    fast_food: "🍔",
    supermarket: "🛒",
    shopping_mall: "🏬",
    coffee_shop: "☕"
};

export const FAMOUS_LOCATIONS = {
    popularLocations: [
        'Walmart', 'Target', 'Costco', 'Best Buy', 'Apple Store',
        'Nordstrom', 'Macy\'s', 'Home Depot', 'Lowe\'s', 'CVS Pharmacy',
        'Walgreens', 'Statue of Liberty', 'Grand Canyon', 'Times Square',
        'Golden Gate Bridge', 'Empire State Building', 'White House',
        'Disney World', 'Disneyland', 'Universal Studios', 'Space Needle',
        'Central Park', 'Navy Pier', 'Pike Place Market', 'Fenway Park'
    ],
    school: [
        'Harvard University', 'Stanford University', 'Massachusetts Institute of Technology',
        'California Institute of Technology', 'Princeton University', 'Yale University',
        'Columbia University', 'University of Chicago', 'University of Pennsylvania',
        'Cornell University', 'Duke University', 'Johns Hopkins University'
    ],
    hospital: [
        'Mayo Clinic', 'Cleveland Clinic', 'Johns Hopkins Hospital',
        'Massachusetts General Hospital', 'UCLA Medical Center', 'NYU Langone Health',
        'Cedars-Sinai Medical Center', 'Stanford Health Care', 'UCSF Medical Center',
        'Northwestern Memorial Hospital'
    ],
    fast_food: [
        'McDonald\'s', 'Starbucks', 'Subway', 'Taco Bell', 'Burger King',
        'Wendy\'s', 'Chick-fil-A', 'Domino\'s', 'Pizza Hut', 'KFC',
        'Chipotle', 'Panera Bread', 'Five Guys', 'In-N-Out Burger'
    ],
    supermarket: [
        'Walmart', 'Target', 'Kroger', 'Albertsons', 'Safeway', 'Publix',
        'Whole Foods Market', 'Trader Joe\'s', 'Aldi', 'Costco'
    ],
    shopping_mall: [
        'Mall of America', 'King of Prussia Mall', 'South Coast Plaza',
        'Aventura Mall', 'The Grove', 'Tysons Corner Center'
    ],
    coffee_shop: [
        'Starbucks', 'Dunkin\'', 'Peet\'s Coffee', 'Tim Hortons',
        'Caribou Coffee', 'Dutch Bros', 'Blue Bottle Coffee'
    ]
};

// Grid clustering configuration
export const GRID_ROWS = 5;
export const GRID_COLS = 5;
















 js/user-analysis/coordinates.js 




// ==================== COORDINATE PROJECTION AND CALCULATIONS ====================

import { 
    rectangleBounds, 
    selectedSiteLocation,
    MAP_WIDTH, 
    MAP_HEIGHT,
    allPOIsDataByCategory,
    highwayData
} from './state.js';

/**
 * Calculate rectangle bounds from center point and radius
 */
export function calculateRectangleBounds(lat, lng, radiusMiles) {
    const radiusKm = radiusMiles * 1.60934;

    // Calculate degrees of latitude (constant at ~111.32 km per degree)
    const latDiff = radiusKm / 111.32;

    // Calculate degrees of longitude (varies with latitude)
    const lngDiff = radiusKm / (111.32 * Math.cos(lat * Math.PI / 180));

    // For Web Mercator, we need to account for the projection distortion
    // Add 10% padding to ensure the circle fits when projected
    const paddingFactor = 1.10;

    return {
        north: lat + (latDiff * paddingFactor),
        south: lat - (latDiff * paddingFactor),
        east: lng + (lngDiff * paddingFactor),
        west: lng - (lngDiff * paddingFactor),
        topLeft: {
            lat: lat + (latDiff * paddingFactor),
            lng: lng - (lngDiff * paddingFactor)
        },
        topRight: {
            lat: lat + (latDiff * paddingFactor),
            lng: lng + (lngDiff * paddingFactor)
        },
        bottomLeft: {
            lat: lat - (latDiff * paddingFactor),
            lng: lng - (lngDiff * paddingFactor)
        },
        bottomRight: {
            lat: lat - (latDiff * paddingFactor),
            lng: lng + (lngDiff * paddingFactor)
        }
    };
}

/**
 * Convert lat/lng to pixel coordinates using Web Mercator projection
 */
export function latLngToPixel(lat, lng) {
    // Web Mercator projection (same as Leaflet/OpenStreetMap)
    const EARTH_RADIUS = 6378137; // meters
    const MAX_LATITUDE = 85.0511287798;

    // Clamp latitude to valid Mercator range
    const clampedLat = Math.max(Math.min(MAX_LATITUDE, lat), -MAX_LATITUDE);

    // Convert to radians
    const latRad = clampedLat * Math.PI / 180;
    const lngRad = lng * Math.PI / 180;

    // Web Mercator projection formulas
    const mercatorX = lngRad;
    const mercatorY = Math.log(Math.tan(Math.PI / 4 + latRad / 2));

    // Calculate bounds in Mercator coordinates
    const boundsWestRad = rectangleBounds.west * Math.PI / 180;
    const boundsEastRad = rectangleBounds.east * Math.PI / 180;
    const boundsNorthRad = Math.max(Math.min(MAX_LATITUDE, rectangleBounds.north), -MAX_LATITUDE) * Math.PI / 180;
    const boundsSouthRad = Math.max(Math.min(MAX_LATITUDE, rectangleBounds.south), -MAX_LATITUDE) * Math.PI / 180;

    const boundsNorthMerc = Math.log(Math.tan(Math.PI / 4 + boundsNorthRad / 2));
    const boundsSouthMerc = Math.log(Math.tan(Math.PI / 4 + boundsSouthRad / 2));

    // Convert to pixel coordinates
    const x = ((mercatorX - boundsWestRad) / (boundsEastRad - boundsWestRad)) * MAP_WIDTH;
    const y = ((boundsNorthMerc - mercatorY) / (boundsNorthMerc - boundsSouthMerc)) * MAP_HEIGHT;

    return { x, y };
}

/**
 * Calculate all pixel coordinates for POIs and highways
 */
export function calculateAllPixelCoordinates() {
    console.log('Converting coordinates to pixels...');

    // Convert POIs
    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        pois.forEach(poi => {
            const coords = latLngToPixel(poi.lat, poi.lng);
            poi.pixelX = coords.x;
            poi.pixelY = coords.y;
        });
    }

    // Convert highways
    highwayData.forEach(hw => {
        const coords = latLngToPixel(hw.center.lat, hw.center.lng);
        hw.pixelX = coords.x;
        hw.pixelY = coords.y;

        // Convert path points
        hw.pixelPath = hw.path.map(([lat, lng]) => {
            const p = latLngToPixel(lat, lng);
            return [p.x, p.y];
        });
    });

    console.log('✓ Coordinate conversion complete');
}

/**
 * Validate and fix coordinates to ensure they're within bounds
 */
export function validateAndFixCoordinates() {
    console.log('Validating coordinates...');

    // Validate POIs
    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        pois.forEach(poi => {
            // Ensure coordinates are within bounds
            if (poi.lat < rectangleBounds.south || poi.lat > rectangleBounds.north ||
                poi.lng < rectangleBounds.west || poi.lng > rectangleBounds.east) {
                console.warn(`POI ${poi.name} is outside bounds, adjusting...`);
                poi.lat = Math.max(rectangleBounds.south, Math.min(rectangleBounds.north, poi.lat));
                poi.lng = Math.max(rectangleBounds.west, Math.min(rectangleBounds.east, poi.lng));
            }

            // Recalculate pixel coordinates
            const coords = latLngToPixel(poi.lat, poi.lng);
            poi.pixelX = coords.x;
            poi.pixelY = coords.y;
        });
    }

    // Validate highways
    highwayData.forEach(hw => {
        // Filter path points to only include those within bounds
        hw.path = hw.path.filter(([lat, lng]) => {
            return lat >= rectangleBounds.south && lat <= rectangleBounds.north &&
                lng >= rectangleBounds.west && lng <= rectangleBounds.east;
        });

        // Recalculate center if needed
        if (hw.path.length > 0) {
            hw.center.lat = hw.path.reduce((sum, p) => sum + p[0], 0) / hw.path.length;
            hw.center.lng = hw.path.reduce((sum, p) => sum + p[1], 0) / hw.path.length;

            const coords = latLngToPixel(hw.center.lat, hw.center.lng);
            hw.pixelX = coords.x;
            hw.pixelY = coords.y;

            hw.pixelPath = hw.path.map(([lat, lng]) => {
                const p = latLngToPixel(lat, lng);
                return [p.x, p.y];
            });
        }
    });

    console.log('✓ Coordinates validated');
}

/**
 * Recalculate projection after resize or changes
 */
export function recalculateProjection() {
    calculateAllPixelCoordinates();
}

/**
 * Calculate pixel coordinates with validation
 */
export function calculateAllPixelCoordinatesWithValidation() {
    calculateAllPixelCoordinates();
    validateAndFixCoordinates();
}
/**
 * Diagnostic check for map alignment
 */
export function diagnosticMapAlignment() {
    console.log('\n========== MAP ALIGNMENT CHECK ==========');
    
    // Calculate rectangle center
    const rectCenterLat = (rectangleBounds.north + rectangleBounds.south) / 2;
    const rectCenterLng = (rectangleBounds.east + rectangleBounds.west) / 2;
    
    console.log('Rectangle Center (lat/lng):', rectCenterLat, rectCenterLng);
    console.log('Site Location (lat/lng):', selectedSiteLocation.lat, selectedSiteLocation.lng);
    
    // Project both to pixels
    const rectCenterPixel = latLngToPixel(rectCenterLat, rectCenterLng);
    const sitePixel = latLngToPixel(selectedSiteLocation.lat, selectedSiteLocation.lng);
    
    console.log('Rectangle Center (pixels):', rectCenterPixel);
    console.log('Site Location (pixels):', sitePixel);
    console.log('Canvas Center:', MAP_WIDTH / 2, MAP_HEIGHT / 2);
    
    // Check if rectangle center is near canvas center
    const centerOffsetX = Math.abs(rectCenterPixel.x - MAP_WIDTH / 2);
    const centerOffsetY = Math.abs(rectCenterPixel.y - MAP_HEIGHT / 2);
    
    console.log('Offset from canvas center (pixels):', centerOffsetX.toFixed(1), centerOffsetY.toFixed(1));
    
    if (centerOffsetX > 50 || centerOffsetY > 50) {
        console.error('⚠️ WARNING: Rectangle center is NOT near canvas center!');
        console.error('This means map tiles are misaligned with coordinate projection!');
    } else {
        console.log('✓ Rectangle center is correctly aligned with canvas');
    }
    
    console.log('======================================\n');
}












 js/user-analysis/diagnostics.js 



// ==================== DIAGNOSTIC AND DEBUG FUNCTIONS ====================

import { 
    mapCanvas, 
    ctx, 
    MAP_WIDTH, 
    MAP_HEIGHT,
    selectedSiteLocation,
    rectangleBounds,
    allPOIsDataByCategory,
    highwayData,
    poiClusters,
    analysisParams
} from './state.js';

/**
 * Run diagnostic check
 */
export function diagnosticCheck() {
    console.log('\n========== DIAGNOSTIC CHECK ==========');
    console.log('Canvas:', mapCanvas ? 'OK' : 'MISSING');
    console.log('Context:', ctx ? 'OK' : 'MISSING');
    console.log('Map Size:', `${MAP_WIDTH}x${MAP_HEIGHT}`);
    console.log('Site Location:', selectedSiteLocation);
    console.log('Rectangle Bounds:', rectangleBounds);
    console.log('\nPOIs by Category:');
    Object.entries(allPOIsDataByCategory).forEach(([cat, pois]) => {
        console.log(`  ${cat}: ${pois.length} items`);
        if (pois.length > 0) {
            const first = pois[0];
            console.log(`    Sample:`, {
                name: first.name,
                coords: [first.lat, first.lng],
                pixels: [first.pixelX, first.pixelY]
            });
        }
    });
    console.log('\nHighways:', highwayData.length);
    if (highwayData.length > 0) {
        const first = highwayData[0];
        console.log(`  Sample:`, {
            name: first.name,
            pathPoints: first.pixelPath ? first.pixelPath.length : 0,
            center: [first.pixelX, first.pixelY]
        });
    }
    console.log('\nClusters:', poiClusters.length);
    console.log('======================================\n');
}

/**
 * Log complete analysis state
 */
export function logAnalysisState() {
    console.log('=== ANALYSIS STATE ===');
    console.log('Analysis Params:', analysisParams);
    console.log('Site Location:', selectedSiteLocation);
    console.log('Rectangle Bounds:', rectangleBounds);
    console.log('POIs by Category:', Object.keys(allPOIsDataByCategory).map(cat => `${cat}: ${allPOIsDataByCategory[cat].length}`));
    console.log('Highways:', highwayData.length);
    console.log('Clusters:', poiClusters.length);
    console.log('Map Size:', `${MAP_WIDTH}x${MAP_HEIGHT}`);
    console.log('====================');
}

/**
 * Export diagnostics to console
 */
export function exportDiagnostics() {
    const diagnostics = {
        timestamp: new Date().toISOString(),
        canvas: {
            exists: !!mapCanvas,
            context: !!ctx,
            width: MAP_WIDTH,
            height: MAP_HEIGHT
        },
        location: selectedSiteLocation,
        bounds: rectangleBounds,
        pois: Object.keys(allPOIsDataByCategory).reduce((acc, cat) => {
            acc[cat] = {
                count: allPOIsDataByCategory[cat].length,
                sample: allPOIsDataByCategory[cat][0] || null
            };
            return acc;
        }, {}),
        highways: {
            count: highwayData.length,
            sample: highwayData[0] || null
        },
        clusters: {
            count: poiClusters.length
        },
        analysisParams: analysisParams
    };

    console.log('=== DIAGNOSTIC EXPORT ===');
    console.log(JSON.stringify(diagnostics, null, 2));
    console.log('========================');

    return diagnostics;
}

/**
 * Setup global diagnostic functions
 */
export function setupGlobalDiagnostics() {
    window.runDiagnostic = diagnosticCheck;
    window.logState = logAnalysisState;
    window.exportDiagnostics = exportDiagnostics;
}

/**
 * Performance monitoring
 */
export class PerformanceMonitor {
    constructor() {
        this.metrics = {};
    }

    start(label) {
        this.metrics[label] = {
            start: performance.now()
        };
    }

    end(label) {
        if (this.metrics[label]) {
            this.metrics[label].end = performance.now();
            this.metrics[label].duration = this.metrics[label].end - this.metrics[label].start;
            console.log(`⏱️ ${label}: ${this.metrics[label].duration.toFixed(2)}ms`);
        }
    }

    getMetrics() {
        return this.metrics;
    }

    reset() {
        this.metrics = {};
    }
}

// Create global performance monitor
export const perfMonitor = new PerformanceMonitor();

/**
 * Setup global performance monitor
 */
export function setupGlobalPerformanceMonitor() {
    window.perfMonitor = perfMonitor;
}














 js/user-analysis/drag-functionality.js 





// ==================== DRAG FUNCTIONALITY ====================

import {
    isDragMode,
    draggedItem,
    dragStartX,
    dragStartY,
    dragOffsetX,
    dragOffsetY,
    setDragMode,
    setDraggedItem,
    setDragCoordinates,
    mapCanvas,
    MAP_WIDTH,
    MAP_HEIGHT,
    poiClusters,
    allPOIsDataByCategory,
    selectedPOIs,
    highwayData,
    selectedHighways,
    selectedSiteLocation,
    permanentDraggedPositions,
    updatePermanentDraggedPositions,
    isResizeMode  // ⭐ ADD THIS if not already there
} from './state.js';
import { latLngToPixel } from './coordinates.js';
import { showNotification } from './utilities.js';
import { redrawStaticMapSmooth } from './main-render.js';

/**
 * Toggle drag mode on/off
 */
export function toggleDragMode() {
    const newMode = !isDragMode;
    setDragMode(newMode);

    const btn = document.getElementById('dragModeBtn');
    const btnText = document.getElementById('dragBtnText');
    const instructions = document.getElementById('dragInstructions');
    
    // Get resize button
    const resizeBtn = document.getElementById('resizeModeBtn');

    if (newMode) {
        // Enable drag mode
        btn.classList.add('active');
        btnText.textContent = 'Disable Drag Mode';
        instructions.classList.add('show');
        document.body.classList.add('drag-mode-active');

        // Disable resize button
        if (resizeBtn) {
            resizeBtn.disabled = true;
            resizeBtn.style.opacity = '0.5';
            resizeBtn.style.cursor = 'not-allowed';
        }

        // Add drag listeners to canvas
        mapCanvas.addEventListener('mousedown', handleDragStart);
        mapCanvas.addEventListener('mousemove', handleDragMove);
        mapCanvas.addEventListener('mouseup', handleDragEnd);
        mapCanvas.addEventListener('mouseleave', handleDragEnd);

        mapCanvas.removeEventListener('click', handleCanvasClick);
        mapCanvas.style.cursor = 'move';

        console.log('✓ Drag mode ENABLED');
    } else {
        // Disable drag mode
        btn.classList.remove('active');
        btnText.textContent = 'Enable Drag Mode';
        instructions.classList.remove('show');
        document.body.classList.remove('drag-mode-active');

        // Enable resize button
        if (resizeBtn) {
            resizeBtn.disabled = false;
            resizeBtn.style.opacity = '1';
            resizeBtn.style.cursor = 'pointer';
        }

        // Remove drag listeners
        mapCanvas.removeEventListener('mousedown', handleDragStart);
        mapCanvas.removeEventListener('mousemove', handleDragMove);
        mapCanvas.removeEventListener('mouseup', handleDragEnd);
        mapCanvas.removeEventListener('mouseleave', handleDragEnd);

        mapCanvas.addEventListener('click', handleCanvasClick);
        mapCanvas.style.cursor = 'default';
        setDraggedItem(null);

        console.log('✓ Drag mode DISABLED');
    }
}

/**
 * Handle drag start
 */
export function handleDragStart(e) {
    if (!isDragMode) return;

    const rect = mapCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const item = findItemAtPosition(mouseX, mouseY);
    setDraggedItem(item);

    if (item) {
        let currentX = item.x;
        let currentY = item.y;

        // Use dragged position if it exists
        if (item.type === 'cluster' && item.data.isDragged) {
            currentX = item.data.draggedX;
            currentY = item.data.draggedY;
        } else if (item.type === 'poi' && item.data.isDragged) {
            currentX = item.data.draggedX;
            currentY = item.data.draggedY;
        } else if (item.type === 'highway' && item.data.isDragged) {
            currentX = item.data.draggedX;
            currentY = item.data.draggedY;
        } else if (item.type === 'siteMarker' && window.siteMarkerPosition.isDragged) {
            currentX = window.siteMarkerPosition.x;
            currentY = window.siteMarkerPosition.y;
        }
        setDragCoordinates(mouseX, mouseY, mouseX - currentX, mouseY - currentY);

        item.dragStartX = currentX;
        item.dragStartY = currentY;

        mapCanvas.style.cursor = 'grabbing';
        mapCanvas.style.opacity = '0.95'; // Slight transparency during drag

        console.log(`✓ Started dragging ${item.type} from: ${currentX.toFixed(1)}, ${currentY.toFixed(1)}`);
    }
}

/**
 * Handle drag move
 */
export function handleDragMove(e) {
    if (!isDragMode || !draggedItem) return;

    const rect = mapCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Calculate new position
    let newX = mouseX - dragOffsetX;
    let newY = mouseY - dragOffsetY;

    // Keep within bounds
    newX = Math.max(20, Math.min(MAP_WIDTH - 20, newX));
    newY = Math.max(20, Math.min(MAP_HEIGHT - 20, newY));

    // Update both draggedItem AND the actual data object
    if (draggedItem.type === 'cluster') {
        draggedItem.data.isDragged = true;
        draggedItem.data.draggedX = newX;
        draggedItem.data.draggedY = newY;
        draggedItem.x = newX;
        draggedItem.y = newY;
    } else if (draggedItem.type === 'poi') {
        draggedItem.data.isDragged = true;
        draggedItem.data.draggedX = newX;
        draggedItem.data.draggedY = newY;
        draggedItem.x = newX;
        draggedItem.y = newY;
    } else if (draggedItem.type === 'highway') {
        draggedItem.data.isDragged = true;
        draggedItem.data.draggedX = newX;
        draggedItem.data.draggedY = newY;
        draggedItem.x = newX;
        draggedItem.y = newY;
    } else if (draggedItem.type === 'siteMarker') {
        window.siteMarkerPosition.isDragged = true;
        window.siteMarkerPosition.x = newX;
        window.siteMarkerPosition.y = newY;
        draggedItem.x = newX;
        draggedItem.y = newY;
    }

    // Update permanent storage in real-time
    updatePermanentPositionHelper(draggedItem, newX, newY);

    // Throttle redraws using requestAnimationFrame
    if (!window.dragAnimationFrame) {
        window.dragAnimationFrame = requestAnimationFrame(() => {
            redrawStaticMapSmooth();
            window.dragAnimationFrame = null;
        });
    }
}

/**
 * Handle drag end
 */
export function handleDragEnd(e) {
    if (!isDragMode) return;

    if (draggedItem) {
        console.log(`✓ ${draggedItem.type} repositioned to: ${draggedItem.x.toFixed(1)}, ${draggedItem.y.toFixed(1)}`);

        // Store final position in permanent storage
        if (draggedItem.type === 'cluster') {
            updatePermanentDraggedPositions('cluster', draggedItem.data.id, {
                x: draggedItem.x,
                y: draggedItem.y,
                originalX: draggedItem.originalX,
                originalY: draggedItem.originalY
            });
            draggedItem.data.isDragged = true;
            draggedItem.data.draggedX = draggedItem.x;
            draggedItem.data.draggedY = draggedItem.y;

        } else if (draggedItem.type === 'poi') {
            const key = `${draggedItem.data.category}-${draggedItem.data.id}`;
            updatePermanentDraggedPositions('poi', key, {
                x: draggedItem.x,
                y: draggedItem.y,
                originalX: draggedItem.originalX,
                originalY: draggedItem.originalY
            });
            draggedItem.data.isDragged = true;
            draggedItem.data.draggedX = draggedItem.x;
            draggedItem.data.draggedY = draggedItem.y;

        } else if (draggedItem.type === 'highway') {
            const hwIndex = highwayData.indexOf(draggedItem.data);
            updatePermanentDraggedPositions('highway', hwIndex, {
                x: draggedItem.x,
                y: draggedItem.y,
                originalX: draggedItem.originalX,
                originalY: draggedItem.originalY
            });
            draggedItem.data.isDragged = true;
            draggedItem.data.draggedX = draggedItem.x;
            draggedItem.data.draggedY = draggedItem.y;

        } else if (draggedItem.type === 'siteMarker') {
            updatePermanentDraggedPositions('siteMarker', null, {
                x: draggedItem.x,
                y: draggedItem.y,
                originalX: draggedItem.originalX,
                originalY: draggedItem.originalY
            });
            window.siteMarkerPosition.isDragged = true;
            window.siteMarkerPosition.x = draggedItem.x;
            window.siteMarkerPosition.y = draggedItem.y;
        }

        setDraggedItem(null);
        setDragCoordinates(0, 0, 0, 0);


        // Clean up any pending animation frame
        if (window.dragAnimationFrame) {
            cancelAnimationFrame(window.dragAnimationFrame);
            window.dragAnimationFrame = null;
        }
    }

    mapCanvas.style.cursor = 'move';
     mapCanvas.style.opacity = '1'; // Reset opacity
}

/**
 * Find item at position for dragging
 */
export function findItemAtPosition(x, y) {
    const clickRadius = 50;

    // Check site marker
    if (window.siteMarkerPosition) {
        let checkX, checkY, originalX, originalY;

        if (permanentDraggedPositions.siteMarker) {
            checkX = permanentDraggedPositions.siteMarker.x;
            checkY = permanentDraggedPositions.siteMarker.y;
            originalX = permanentDraggedPositions.siteMarker.originalX;
            originalY = permanentDraggedPositions.siteMarker.originalY;
        } else if (window.siteMarkerPosition.isDragged) {
            checkX = window.siteMarkerPosition.x;
            checkY = window.siteMarkerPosition.y;
            const originalCoords = latLngToPixel(selectedSiteLocation.lat, selectedSiteLocation.lng);
            originalX = originalCoords.x;
            originalY = originalCoords.y;
        } else {
            const coords = latLngToPixel(selectedSiteLocation.lat, selectedSiteLocation.lng);
            checkX = coords.x;
            checkY = coords.y;
            originalX = coords.x;
            originalY = coords.y;
        }

        const dist = Math.sqrt(Math.pow(x - checkX, 2) + Math.pow(y - checkY, 2));

        if (dist < clickRadius) {
            return {
                type: 'siteMarker',
                x: checkX,
                y: checkY,
                originalX: originalX,
                originalY: originalY,
                data: window.siteMarkerPosition
            };
        }
    }

    // Check clusters
    for (let cluster of poiClusters) {
        let checkX, checkY;

        if (permanentDraggedPositions.clusters[cluster.id]) {
            checkX = permanentDraggedPositions.clusters[cluster.id].x;
            checkY = permanentDraggedPositions.clusters[cluster.id].y;
        } else if (cluster.isDragged) {
            checkX = cluster.draggedX;
            checkY = cluster.draggedY;
        } else {
            checkX = cluster.clusterX;
            checkY = cluster.clusterY;
        }

        const dist = Math.sqrt(Math.pow(x - checkX, 2) + Math.pow(y - checkY, 2));

        if (dist < clickRadius) {
            return {
                type: 'cluster',
                x: checkX,
                y: checkY,
                originalX: cluster.meanX,
                originalY: cluster.meanY,
                data: cluster
            };
        }
    }

    // Check individual POIs
    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        for (let idx = 0; idx < pois.length; idx++) {
            if (!selectedPOIs[category] || !selectedPOIs[category][idx]) continue;

            const poi = pois[idx];

            // Skip if in cluster
            const isInCluster = poiClusters.some(cluster =>
                cluster.pois.some(p => p.poi === poi)
            );
            if (isInCluster) continue;

            let checkX, checkY;
            const key = `${category}-${poi.id}`;

            if (permanentDraggedPositions.pois[key]) {
                checkX = permanentDraggedPositions.pois[key].x;
                checkY = permanentDraggedPositions.pois[key].y;
            } else if (poi.isDragged) {
                checkX = poi.draggedX;
                checkY = poi.draggedY;
            } else {
                checkX = poi.pixelX;
                checkY = poi.pixelY;
            }

            const dist = Math.sqrt(Math.pow(x - checkX, 2) + Math.pow(y - checkY, 2));

            if (dist < clickRadius) {
                if (!poi.originalPixelX) {
                    poi.originalPixelX = poi.pixelX;
                    poi.originalPixelY = poi.pixelY;
                }

                return {
                    type: 'poi',
                    x: checkX,
                    y: checkY,
                    originalX: poi.originalPixelX,
                    originalY: poi.originalPixelY,
                    data: poi
                };
            }
        }
    }

    // Check highways
    for (let idx = 0; idx < highwayData.length; idx++) {
        if (!selectedHighways[idx]) continue;

        const hw = highwayData[idx];
        let checkX, checkY;

        if (permanentDraggedPositions.highways[idx]) {
            checkX = permanentDraggedPositions.highways[idx].x;
            checkY = permanentDraggedPositions.highways[idx].y;
        } else if (hw.isDragged) {
            checkX = hw.draggedX;
            checkY = hw.draggedY;
        } else {
            checkX = hw.pixelX;
            checkY = hw.pixelY;
        }

        const dist = Math.sqrt(Math.pow(x - checkX, 2) + Math.pow(y - checkY, 2));

        if (dist < clickRadius) {
            if (!hw.originalPixelX) {
                hw.originalPixelX = hw.pixelX;
                hw.originalPixelY = hw.pixelY;
            }

            return {
                type: 'highway',
                x: checkX,
                y: checkY,
                originalX: hw.originalPixelX,
                originalY: hw.originalPixelY,
                data: hw
            };
        }
    }

    return null;
}

/**
 * Update permanent position helper
 */
function updatePermanentPositionHelper(item, x, y) {
    if (!item) return;

    if (item.type === 'cluster') {
        updatePermanentDraggedPositions('cluster', item.data.id, {
            x: x,
            y: y,
            originalX: item.originalX,
            originalY: item.originalY
        });
    } else if (item.type === 'poi') {
        const key = `${item.data.category}-${item.data.id}`;
        updatePermanentDraggedPositions('poi', key, {
            x: x,
            y: y,
            originalX: item.originalX,
            originalY: item.originalY
        });
    } else if (item.type === 'highway') {
        const hwIndex = highwayData.indexOf(item.data);
        if (hwIndex !== -1) {
            updatePermanentDraggedPositions('highway', hwIndex, {
                x: x,
                y: y,
                originalX: item.originalX,
                originalY: item.originalY
            });
        }
    } else if (item.type === 'siteMarker') {
        updatePermanentDraggedPositions('siteMarker', null, {
            x: x,
            y: y,
            originalX: item.originalX,
            originalY: item.originalY
        });
    }
}

/**
 * Restore dragged positions after redraw
 */
export function restoreDraggedPositions() {
    console.log('Restoring dragged positions...');

    // Restore POIs
    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        pois.forEach(poi => {
            const key = `${category}-${poi.id}`;
            if (permanentDraggedPositions.pois[key]) {
                const saved = permanentDraggedPositions.pois[key];
                poi.isDragged = true;
                poi.draggedX = saved.x;
                poi.draggedY = saved.y;
                poi.originalPixelX = saved.originalX;
                poi.originalPixelY = saved.originalY;
            }
        });
    }

    // Restore clusters
    poiClusters.forEach(cluster => {
        if (permanentDraggedPositions.clusters[cluster.id]) {
            const saved = permanentDraggedPositions.clusters[cluster.id];
            cluster.isDragged = true;
            cluster.draggedX = saved.x;
            cluster.draggedY = saved.y;
        }
    });

    // Restore highways
    highwayData.forEach((hw, index) => {
        if (permanentDraggedPositions.highways[index]) {
            const saved = permanentDraggedPositions.highways[index];
            hw.isDragged = true;
            hw.draggedX = saved.x;
            hw.draggedY = saved.y;
            hw.originalPixelX = saved.originalX;
            hw.originalPixelY = saved.originalY;
        }
    });

    // Restore site marker
    if (permanentDraggedPositions.siteMarker && window.siteMarkerPosition) {
        const saved = permanentDraggedPositions.siteMarker;
        window.siteMarkerPosition.isDragged = true;
        window.siteMarkerPosition.x = saved.x;
        window.siteMarkerPosition.y = saved.y;
    }

    console.log('✓ Dragged positions restored');
}

/**
 * Canvas click handler (for popups when not in drag mode)
 */
export function handleCanvasClick(event) {
    if (isDragMode) return;

    // ⭐ ADD THIS: Check if resize mode is active
    if (isResizeMode) return;

    const rect = mapCanvas.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;

    console.log(`Canvas clicked at: ${clickX}, ${clickY}`);

    // Check if clicked on site marker
    if (window.siteMarkerPosition) {
        let siteX, siteY;

        if (window.siteMarkerPosition.isDragged) {
            siteX = window.siteMarkerPosition.x;
            siteY = window.siteMarkerPosition.y;
        } else {
            const coords = latLngToPixel(selectedSiteLocation.lat, selectedSiteLocation.lng);
            siteX = coords.x;
            siteY = coords.y;
        }

        const distance = Math.sqrt(
            Math.pow(clickX - siteX, 2) +
            Math.pow(clickY - siteY, 2)
        );

        if (distance < 30) {
            showSiteMarkerPopup(event.clientX, event.clientY);
            return;
        }
    }

    // Check if clicked on any POI
    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        for (let idx = 0; idx < pois.length; idx++) {
            if (!selectedPOIs[category] || !selectedPOIs[category][idx]) continue;

            const poi = pois[idx];
            const poiX = poi.isDragged ? poi.draggedX : poi.pixelX;
            const poiY = poi.isDragged ? poi.draggedY : poi.pixelY;

            const distance = Math.sqrt(
                Math.pow(clickX - poiX, 2) +
                Math.pow(clickY - poiY, 2)
            );

            if (distance < poi.logoSize / 2 + 10) {
                showPOIPopup(poi, event.clientX, event.clientY);
                return;
            }
        }
    }

    // Check clusters
    poiClusters.forEach(cluster => {
        const clusterX = cluster.isDragged ? cluster.draggedX : cluster.clusterX;
        const clusterY = cluster.isDragged ? cluster.draggedY : cluster.clusterY;

        const distance = Math.sqrt(
            Math.pow(clickX - clusterX, 2) +
            Math.pow(clickY - clusterY, 2)
        );

        if (distance < cluster.size / 2) {
            showClusterPopup(cluster, event.clientX, event.clientY);
        }
    });
}

/**
 * Show POI popup
 */
function showPOIPopup(poi, clientX, clientY) {
    const existing = document.getElementById('poiPopup');
    if (existing) existing.remove();

    const popup = document.createElement('div');
    popup.id = 'poiPopup';
    popup.style.cssText = `
        position: fixed;
        left: ${clientX + 10}px;
        top: ${clientY + 10}px;
        background: white;
        border: 3px solid #8B0000;
        border-radius: 10px;
        padding: 15px;
        padding-top: 35px;
        box-shadow: 0 8px 30px rgba(0,0,0,0.3);
        z-index: 10000;
        max-width: 300px;
        font-family: 'Segoe UI', sans-serif;
    `;

    popup.innerHTML = `
        <button onclick="document.getElementById('poiPopup').remove()" 
                style="position: absolute; top: 5px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: #8B0000; padding: 0; line-height: 1;">&times;</button>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            ${poi.logoUrl ? `<img src="${poi.logoUrl}" style="width: 40px; height: 40px; border-radius: 5px;">` : '<span style="font-size: 30px;">⭐</span>'}
            <strong style="color: #8B0000; font-size: 16px;">${poi.name}</strong>
        </div>
        <div style="font-size: 13px; line-height: 1.6; color: #333;">
            <div style="margin-bottom: 8px;">
                <i class="fas fa-map-marker-alt" style="color: #8B0000; width: 20px;"></i>
                <strong>Address:</strong><br>
                <span style="margin-left: 25px;">${poi.address || 'N/A'}</span>
            </div>
            <div style="margin-bottom: 8px;">
                <i class="fas fa-mail-bulk" style="color: #8B0000; width: 20px;"></i>
                <strong>Zip Code:</strong> ${poi.postalCode || 'N/A'}
            </div>
            <div style="margin-bottom: 8px;">
                <i class="fas fa-crosshairs" style="color: #8B0000; width: 20px;"></i>
                <strong>Coordinates:</strong><br>
                <span style="margin-left: 25px;">${poi.coordinates}</span>
            </div>
            <div>
                <i class="fas fa-route" style="color: #8B0000; width: 20px;"></i>
                <strong>Distance:</strong> ${poi.distanceMiles.toFixed(2)} miles
            </div>
        </div>
    `;

    document.body.appendChild(popup);

    setTimeout(() => {
        if (document.getElementById('poiPopup')) {
            popup.remove();
        }
    }, 10000);
}

/**
 * Show cluster popup
 */
function showClusterPopup(cluster, clientX, clientY) {
    const existing = document.getElementById('poiPopup');
    if (existing) existing.remove();

    const popup = document.createElement('div');
    popup.id = 'poiPopup';
    popup.style.cssText = `
        position: fixed;
        left: ${clientX + 10}px;
        top: ${clientY + 10}px;
        background: white;
        border: 3px solid #8B0000;
        border-radius: 10px;
        padding: 15px;
        padding-top: 35px;
        box-shadow: 0 8px 30px rgba(0,0,0,0.3);
        z-index: 10000;
        max-width: 350px;
        max-height: 400px;
        overflow-y: auto;
        font-family: 'Segoe UI', sans-serif;
    `;

    let content = `
        <button onclick="document.getElementById('poiPopup').remove()" 
                style="position: absolute; top: 5px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: #8B0000; padding: 0; line-height: 1;">&times;</button>
        <h4 style="color: #8B0000; margin-bottom: 10px;">Cluster (${cluster.pois.length} locations)</h4>
    `;

    cluster.pois.forEach((poiData, idx) => {
        const poi = poiData.poi;
        content += `
            <div style="padding: 10px; margin-bottom: 8px; background: #f8f9fa; border-radius: 5px; font-size: 12px;">
                <strong>${idx + 1}. ${poi.name}</strong><br>
                <span style="color: #666;">📍 ${poi.address || 'N/A'}</span><br>
                <span style="color: #666;">📮 ${poi.postalCode || 'N/A'}</span><br>
                <span style="color: #666;">🎯 ${poi.distanceMiles.toFixed(2)} mi</span>
            </div>
        `;
    });

    popup.innerHTML = content;
    document.body.appendChild(popup);
}

/**
 * Show site marker popup with address only
 */
function showSiteMarkerPopup(clientX, clientY) {
    const existing = document.getElementById('poiPopup');
    if (existing) existing.remove();

    const popup = document.createElement('div');
    popup.id = 'poiPopup';
    popup.style.cssText = `
        position: fixed;
        left: ${clientX + 10}px;
        top: ${clientY + 10}px;
        background: white;
        border: 3px solid #00FF00;
        border-radius: 10px;
        padding: 15px;
        padding-top: 35px;
        box-shadow: 0 8px 30px rgba(0,0,0,0.3);
        z-index: 10000;
        max-width: 350px;
        font-family: 'Segoe UI', sans-serif;
    `;

    popup.innerHTML = `
        <button onclick="document.getElementById('poiPopup').remove()" 
                style="position: absolute; top: 5px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: #00FF00; padding: 0; line-height: 1;">&times;</button>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span style="font-size: 30px;">📍</span>
            <strong style="color: #00FF00; font-size: 16px;">Site Location</strong>
        </div>
        <div style="font-size: 13px; line-height: 1.6; color: #333;">
            <div style="margin-bottom: 8px;">
                <i class="fas fa-map-marker-alt" style="color: #00FF00; width: 20px;"></i>
                <strong>Address:</strong><br>
                <span style="margin-left: 25px;">${selectedSiteLocation.address}</span>
            </div>
        </div>
    `;

    document.body.appendChild(popup);

    setTimeout(() => {
        if (document.getElementById('poiPopup')) {
            popup.remove();
        }
    }, 10000);
}











 js/user-analysis/highway-fetching.js 



// ==================== HIGHWAY DATA FETCHING AND PROCESSING ====================

import { selectedSiteLocation, analysisParams, setHighwayData, setSelectedHighways } from './state.js';
import { calculateDistance } from './utilities.js';
import { fetchWithRetry } from './api-fetching.js';

/**
 * Fetch highways from Overpass API
 */
export async function fetchHighways() {
    const radiusMeters = analysisParams.radius * 1609.34;
    const query = `[out:json][timeout:15];(
        way["highway"~"tertiary|secondary|primary|trunk|motorway"](around:${radiusMeters},${selectedSiteLocation.lat},${selectedSiteLocation.lng});
    );out body;>;out skel qt;`;

    try {
        console.log('Fetching highways (attempt 1/3)...');

        const data = await fetchWithRetry('https://overpass-api.de/api/interpreter', {
            method: 'POST',
            body: query,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        });

        console.log(`✓ Highways: received ${data.elements ? data.elements.length : 0} results`);

        const processedHighways = processHighwayData(data.elements || []);
        setHighwayData(processedHighways);

        // Initialize all highways as selected
        setSelectedHighways(processedHighways.map(() => true));

        console.log(`✓ Processed ${processedHighways.length} highways`);
    } catch (error) {
        console.error('✗ Failed to fetch highways after retries:', error.message);
        setHighwayData([]);
        setSelectedHighways([]);
    }
}

/**
 * Process highway data from Overpass API
 */
export function processHighwayData(elements) {
    const nodes = {};
    elements.forEach(el => {
        if (el.type === 'node') {
            nodes[el.id] = { lat: el.lat, lng: el.lon };
        }
    });

    const highways = elements.filter(el => el.type === 'way' && el.tags && el.tags.highway);
    let processed = highways.map(way => {
        const path = way.nodes.map(nodeId => {
            const node = nodes[nodeId];
            return node ? [node.lat, node.lng] : null;
        }).filter(Boolean);

        if (path.length === 0) return null;

        const center = {
            lat: path.reduce((sum, p) => sum + p[0], 0) / path.length,
            lng: path.reduce((sum, p) => sum + p[1], 0) / path.length
        };
        const distanceMiles = calculateDistance(
            selectedSiteLocation.lat, 
            selectedSiteLocation.lng, 
            center.lat, 
            center.lng
        ) / 1.60934;

        return {
            id: way.id,
            type: way.tags.highway,
            name: way.tags.name || 'Unnamed Road',
            ref: way.tags.ref,
            path,
            center,
            distanceMiles,
            pixelX: 0,
            pixelY: 0,
            pixelPath: []
        };
    }).filter(h => h && h.path.length > 1).sort((a, b) => a.distanceMiles - b.distanceMiles);

    const result = [];
    const targetTypes = ['motorway', 'trunk', 'primary', 'tertiary'];

    for (const targetType of targetTypes) {
        const found = processed.find(hw => hw.type === targetType);
        if (found) {
            result.push(found);
        }
    }

    return result.slice(0, 4);
}

















 js/user-analysis/initialization.js







// ==================== INITIALIZATION AND MAIN FLOW ====================

import { 
    setAnalysisParams, 
    setSelectedSiteLocation, 
    setRectangleBounds,
    analysisParams 
} from './state.js';
import { calculateRectangleBounds, calculateAllPixelCoordinatesWithValidation } from './coordinates.js';
import { fetchAllPOIs } from './api-fetching.js';
import { fetchHighways } from './highway-fetching.js';
import { createPOIClusters } from './clustering.js';
import { updateInfoPanels } from './ui-updates.js';
import { renderStaticMap } from './main-render.js';
import { delay } from './utilities.js';
import { debounce } from './utilities.js';
import { updateCanvasSize } from './canvas-setup.js';
import { redrawStaticMap } from './main-render.js';

/**
 * Main initialization on window load
 */
export async function initializeAnalysis() {
    try {
        // Check authentication
        const user = sessionStorage.getItem('ssnai_user') || localStorage.getItem('ssnai_user');
        if (!user) {
            window.location.href = 'login.html';
            return;
        }

        // Get analysis parameters
        const params = JSON.parse(sessionStorage.getItem('analysis_params'));
        if (!params) {
            alert('No analysis parameters found');
            window.location.href = 'dashboard.html';
            return;
        }

        setAnalysisParams(params);

        // Start analysis
        await performAnalysis();
    } catch (error) {
        console.error('Initialization error:', error);
        alert('Error initializing analysis: ' + error.message);
    }
}

/**
 * Main analysis flow
 */
export async function performAnalysis() {
    try {
        // Geocode address
        const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(analysisParams.address)}&limit=1`
        );
        const data = await response.json();

        if (data && data.length > 0) {
            const location = {
                lat: parseFloat(data[0].lat),
                lng: parseFloat(data[0].lon),
                address: data[0].display_name
            };
            setSelectedSiteLocation(location);

            console.log(`Site location: ${location.lat}, ${location.lng}`);

            // Calculate rectangle bounds with padding
            const bounds = calculateRectangleBounds(
                location.lat,
                location.lng,
                analysisParams.radius
            );
            setRectangleBounds(bounds);

            console.log('Rectangle bounds calculated:', bounds);

            // Fetch all data
            console.log('Fetching POIs...');
            await fetchAllPOIs();

            console.log('Waiting before highway fetch...');
            await delay(2000);

            console.log('Fetching highways...');
            await fetchHighways();

            // Calculate pixel coordinates with validation
            console.log('Calculating coordinates...');
            calculateAllPixelCoordinatesWithValidation();

            // Create clusters
            console.log('Creating clusters...');
            createPOIClusters();

            // Hide loading, show content
            document.getElementById('loadingOverlay').style.display = 'none';
            document.getElementById('mainContent').style.display = 'grid';

            console.log('Updating UI panels...');
            updateInfoPanels();

            console.log('Rendering static map...');
            await renderStaticMap();

            console.log('✓ Analysis complete!');
        } else {
            alert('Location not found');
            window.location.href = 'dashboard.html';
        }
    } catch (error) {
        console.error('Analysis error:', error);
        alert('Error performing analysis: ' + error.message);
        console.error('Stack trace:', error.stack);
    }
}

/**
 * Setup window resize handler
 */
export function setupResizeHandler() {
    const handleResize = debounce(() => {
        console.log('Window resized, updating canvas...');
        updateCanvasSize();
        calculateAllPixelCoordinatesWithValidation();
        createPOIClusters();
        redrawStaticMap();
    }, 300);

    window.addEventListener('resize', handleResize);
}

/**
 * Setup error handlers
 */
export function setupErrorHandlers() {
    window.addEventListener('error', (event) => {
        console.error('Global error caught:', event.error);

        const loadingOverlay = document.getElementById('loadingOverlay');
        if (loadingOverlay) {
            loadingOverlay.innerHTML = `
                <div class="loading-content">
                    <h2 style="color: #dc3545;">Error</h2>
                    <p>Something went wrong: ${event.error.message}</p>
                    <button onclick="window.location.href='dashboard.html'" 
                            style="margin-top: 20px; padding: 10px 20px; background: white; color: #8B0000; border: none; border-radius: 5px; cursor: pointer;">
                        Return to Dashboard
                    </button>
                </div>
            `;
        }
    });

    window.addEventListener('unhandledrejection', (event) => {
        console.error('Unhandled promise rejection:', event.reason);
    });
}

/**
 * Cleanup on page unload
 */
export function setupCleanupHandlers() {
    window.addEventListener('beforeunload', () => {
        // Clear caches if needed
        console.log('Cleaning up...');
    });
}















  js/user-analysis/main-render.js 




// ==================== MAIN RENDERING ORCHESTRATION ====================

import { 
    mapCanvas, 
    ctx,
    setMapCanvas,
    setMapContext
} from './state.js';
import { initializeCanvas, updateCanvasSize, clearCanvas } from './canvas-setup.js';
import { calculateAllPixelCoordinatesWithValidation, diagnosticMapAlignment } from './coordinates.js';
import { drawMapTilesOptimized } from './map-tiles.js';
import { drawSiteMarker, drawHighwaysStaticEnhanced, drawIndividualPOIsEnhanced } from './rendering.js';
import { drawClustersEnhanced, drawClusters } from './cluster-rendering.js';
import { createPOIClusters, optimizeClusterPositions } from './clustering.js';
import { restoreDraggedPositions } from './drag-functionality.js';
import { restoreResizedSizes } from './resize-functionality.js';

/**
 * Render static map (main entry point)
 */
export async function renderStaticMap() {
    const success = initializeCanvas();
    if (!success) return;

    // Calculate projections with validation
    calculateAllPixelCoordinatesWithValidation();

    // ADD THIS LINE: Run diagnostic check
    diagnosticMapAlignment();

    // Load map tiles
    console.log('Loading map tiles...');
    await drawMapTilesOptimized();

    console.log('✓ Map tiles loaded');

    // Create clusters
    createPOIClusters();

    // Render complete map
    await redrawStaticMapComplete();

    console.log('✓ Static map rendered');
}

/**
 * Complete map redraw with full recalculation
 */
export async function redrawStaticMapComplete() {
    console.log('\n========== REDRAWING MAP ==========');

    if (!ctx || !mapCanvas) {
        console.error('Canvas or context not available!');
        return;
    }

    // Clear canvas
    console.log('1. Clearing canvas...');
    clearCanvas();

    // Draw map tiles
    console.log('2. Drawing map tiles...');
    await drawMapTilesOptimized();

    // Restore dragged positions
    console.log('3. Restoring dragged positions...');
    restoreDraggedPositions();

    // Restore resized sizes
    console.log('3.5. Restoring resized sizes...');
    restoreResizedSizes();

    // Draw site marker
    console.log('4. Drawing site marker...');
    drawSiteMarker();

    // Draw highways
    console.log('6. Drawing highways...');
    drawHighwaysStaticEnhanced();

    // Draw individual POIs
    console.log('7. Drawing individual POIs...');
    drawIndividualPOIsEnhanced();

    // Optimize cluster positions
    console.log('8. Optimizing cluster positions...');
    optimizeClusterPositions();

    // Draw clusters
    console.log('9. Drawing clusters...');
    drawClustersEnhanced();

    console.log('========== MAP REDRAW COMPLETE ==========\n');
}

/**
 * Smooth redraw without position reset (for drag operations)
 */
export async function redrawStaticMapSmooth() {
    console.log('\n========== SMOOTH REDRAW (No Position Reset) ==========');

    if (!ctx || !mapCanvas) {
        console.error('Canvas or context not available!');
        return;
    }

    // Clear canvas
    clearCanvas();

    // Draw map tiles
    await drawMapTilesOptimized();

    // Restore all dragged positions
    restoreDraggedPositions();
    // Restore all resized sizes
    restoreResizedSizes();

    // Draw everything
    drawSiteMarker();
    drawHighwaysStaticEnhanced();
    drawIndividualPOIsEnhanced();
    drawClustersEnhanced();

    console.log('========== SMOOTH REDRAW COMPLETE ==========\n');
}

/**
 * Basic static map redraw
 */
export async function redrawStaticMap() {
    if (!ctx || !mapCanvas) return;

    // Clear canvas
    clearCanvas();

    // Redraw map tiles
    await drawMapTilesOptimized();

    // Draw all elements
    drawSiteMarker();
    drawHighwaysStaticEnhanced();
    drawIndividualPOIsEnhanced();
    drawClusters();
}











  js/user-analysis/map-tiles.js 




// ==================== MAP TILE LOADING AND CACHING ====================

import { ctx, MAP_WIDTH, MAP_HEIGHT, rectangleBounds } from './state.js';
import { loadImage } from './utilities.js';

// Tile cache for performance
const tileCache = new Map();

/**
 * Load tile with caching
 */
export async function loadTileCached(tileUrl) {
    if (tileCache.has(tileUrl)) {
        return tileCache.get(tileUrl);
    }

    try {
        const img = await loadImage(tileUrl);
        tileCache.set(tileUrl, img);
        return img;
    } catch (error) {
        console.warn(`Failed to load tile: ${tileUrl}`);
        throw error;
    }
}

/**
 * Draw map tiles scaled to match rectangle bounds exactly
 */
export async function drawMapTilesOptimized() {
    const zoom = 14;
    const tileSize = 256;

    console.log('Drawing map tiles with bounds scaling...');
    console.log('Rectangle bounds:', rectangleBounds);
    console.log('Canvas size:', MAP_WIDTH, 'x', MAP_HEIGHT);

    // Fill background
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);

    // Convert bounds to tile coordinates
    const minTileX = Math.floor((rectangleBounds.west + 180) / 360 * Math.pow(2, zoom));
    const maxTileX = Math.ceil((rectangleBounds.east + 180) / 360 * Math.pow(2, zoom));
    
    const minTileY = Math.floor((1 - Math.log(Math.tan(rectangleBounds.north * Math.PI / 180) + 
                     1 / Math.cos(rectangleBounds.north * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
    const maxTileY = Math.ceil((1 - Math.log(Math.tan(rectangleBounds.south * Math.PI / 180) + 
                    1 / Math.cos(rectangleBounds.south * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));

    console.log('Tile range:', `X: ${minTileX}-${maxTileX}, Y: ${minTileY}-${maxTileY}`);

    // Calculate exact pixel positions for bounds corners
    const westTileCoord = (rectangleBounds.west + 180) / 360 * Math.pow(2, zoom);
    const eastTileCoord = (rectangleBounds.east + 180) / 360 * Math.pow(2, zoom);
    const northTileCoord = (1 - Math.log(Math.tan(rectangleBounds.north * Math.PI / 180) + 
                           1 / Math.cos(rectangleBounds.north * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom);
    const southTileCoord = (1 - Math.log(Math.tan(rectangleBounds.south * Math.PI / 180) + 
                           1 / Math.cos(rectangleBounds.south * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom);

    // Calculate scale factors to stretch tiles to canvas
    const tilesWidth = eastTileCoord - westTileCoord;
    const tilesHeight = southTileCoord - northTileCoord;
    const pixelsPerTileX = MAP_WIDTH / tilesWidth;
    const pixelsPerTileY = MAP_HEIGHT / tilesHeight;

    console.log('Scale factors:', `X: ${pixelsPerTileX.toFixed(2)}, Y: ${pixelsPerTileY.toFixed(2)}`);

    const tilePromises = [];

    // Draw tiles with proper scaling
    for (let tileX = minTileX; tileX <= maxTileX; tileX++) {
        for (let tileY = minTileY; tileY <= maxTileY; tileY++) {
            // Skip invalid tiles
            if (tileX < 0 || tileY < 0 || tileX >= Math.pow(2, zoom) || tileY >= Math.pow(2, zoom)) {
                continue;
            }

            const tileUrl = `https://tile.openstreetmap.org/${zoom}/${tileX}/${tileY}.png`;

            // Calculate pixel position and size for this tile
            const drawX = (tileX - westTileCoord) * pixelsPerTileX;
            const drawY = (tileY - northTileCoord) * pixelsPerTileY;
            const drawWidth = pixelsPerTileX;
            const drawHeight = pixelsPerTileY;

            tilePromises.push(
                loadTileCached(tileUrl)
                    .then(img => {
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                    })
                    .catch(() => {
                        // Draw placeholder for failed tiles
                        ctx.fillStyle = '#e0e0e0';
                        ctx.fillRect(drawX, drawY, drawWidth, drawHeight);
                    })
            );
        }
    }

    await Promise.all(tilePromises);
    console.log('✓ Map tiles loaded and scaled to bounds');
}

/**
 * Draw basic map tiles
 */
export async function drawMapTiles() {
    await drawMapTilesOptimized();
}

/**
 * Clear tile cache
 */
export function clearTileCache() {
    tileCache.clear();
}
















  js/user-analysis/rendering.js 






// ==================== CANVAS RENDERING FUNCTIONS ====================

import {
    ctx,
    MAP_WIDTH,
    MAP_HEIGHT,
    selectedSiteLocation,
    allPOIsDataByCategory,
    highwayData,
    selectedHighways,
    selectedPOIs,
    poiClusters,
    analysisParams
} from './state.js';
import { latLngToPixel } from './coordinates.js';
import { getHighwayColor, isWithinMapBounds, loadImage } from './utilities.js';
import { checkCollisionWithHighways, findSafePosition } from './clustering.js';

// Logo cache for performance
const logoCache = new Map();

/**
 * Load image with caching
 */
export async function loadImageCached(url) {
    if (logoCache.has(url)) {
        return logoCache.get(url);
    }

    try {
        const img = await loadImage(url);
        logoCache.set(url, img);
        return img;
    } catch (error) {
        console.warn(`Failed to load image: ${url}`);
        throw error;
    }
}

/**
 * Draw site marker (green circle with 'S')
 */
export function drawSiteMarker() {
    const siteCoords = latLngToPixel(selectedSiteLocation.lat, selectedSiteLocation.lng);

    console.log('Drawing site marker at:', siteCoords);
    // ==================== USE RESIZED RADIUS HERE ====================
    // Use resized radius if available
    const markerRadius = window.siteMarkerPosition?.radius || 20;
    // ==================== END RESIZED RADIUS ====================


    if (siteCoords.x < 0 || siteCoords.x > MAP_WIDTH ||
        siteCoords.y < 0 || siteCoords.y > MAP_HEIGHT) {
        console.error('⚠️ Site marker position is outside canvas!');
        return;
    }

    let drawX = siteCoords.x;
    let drawY = siteCoords.y;

    if (window.siteMarkerPosition && window.siteMarkerPosition.isDragged) {
        drawX = window.siteMarkerPosition.x;
        drawY = window.siteMarkerPosition.y;

        // Draw orange circle at original position
        ctx.fillStyle = '#FF8C00';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(siteCoords.x, siteCoords.y, 8, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();

        // Draw bold orange line
        ctx.strokeStyle = '#FF8C00';
        ctx.lineWidth = 6;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(siteCoords.x, siteCoords.y);
        ctx.lineTo(drawX, drawY);
        ctx.stroke();
    }

    // Store site marker position globally
    if (!window.siteMarkerPosition) {
        window.siteMarkerPosition = { x: drawX, y: drawY, radius: 25 };
    } else {
        window.siteMarkerPosition.x = drawX;
        window.siteMarkerPosition.y = drawY;
    }

    // Draw green circle with 'S'
    ctx.fillStyle = '#00FF00';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(drawX, drawY, markerRadius, 0, 2 * Math.PI);  // ⭐ CHANGED
    ctx.fill();
    ctx.stroke();

    // Draw 'S' letter
    ctx.fillStyle = 'white';
    ctx.font = `bold ${Math.floor(markerRadius * 0.9)}px Arial`;  // ⭐ SCALE FONT
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('S', drawX, drawY);

    console.log('✓ Site marker drawn');
}

/**
 * Draw search radius circle (enhanced version)
 */
export function drawSearchRadiusEnhanced() {
    const siteCoords = latLngToPixel(selectedSiteLocation.lat, selectedSiteLocation.lng);
    const radiusMiles = analysisParams.radius;

    // Calculate a point at the edge of the radius
    const radiusDegrees = (radiusMiles * 1609.34) / (111320 * Math.cos(selectedSiteLocation.lat * Math.PI / 180));
    const edgePoint = {
        lat: selectedSiteLocation.lat,
        lng: selectedSiteLocation.lng + radiusDegrees
    };

    const edgeCoords = latLngToPixel(edgePoint.lat, edgePoint.lng);
    const radiusPixels = Math.abs(edgeCoords.x - siteCoords.x);

    console.log(`Radius: ${radiusMiles} miles = ${radiusPixels.toFixed(1)} pixels at this zoom level`);
}

/**
 * Draw highways (static enhanced version)
 */
export function drawHighwaysStaticEnhanced() {
    console.log(`\nDrawing ${highwayData.length} highways...`);

    let drawnCount = 0;
    highwayData.forEach((hw, idx) => {
        if (!selectedHighways[idx]) return;

        if (!hw.pixelPath || hw.pixelPath.length < 2) {
            console.warn(`Highway ${hw.name} has insufficient path points`);
            return;
        }

        // Draw highway path
        ctx.strokeStyle = getHighwayColor(hw.type);
        ctx.lineWidth = 4;
        ctx.beginPath();

        let validPoints = 0;
        hw.pixelPath.forEach((point, i) => {
            if (isWithinMapBounds(point[0], point[1], MAP_WIDTH, MAP_HEIGHT)) {
                if (i === 0 || validPoints === 0) {
                    ctx.moveTo(point[0], point[1]);
                } else {
                    ctx.lineTo(point[0], point[1]);
                }
                validPoints++;
            }
        });

        if (validPoints >= 2) {
            ctx.stroke();
            drawnCount++;

            if (isWithinMapBounds(hw.pixelX, hw.pixelY, MAP_WIDTH, MAP_HEIGHT)) {
                drawHighwayLabel(hw);
            }
        } else {
            console.warn(`Highway ${hw.name} has no valid points within bounds`);
        }
    });

    console.log(`✓ Drew ${drawnCount} highways`);
}

/**
 * Draw highway label
 */
export function drawHighwayLabel(hw) {
    const label = hw.ref || hw.name.substring(0, 10);
    const color = getHighwayColor(hw.type);

    const fontSize = hw.labelSize || 14;
    ctx.font = `bold ${fontSize}px Arial`;
    const metrics = ctx.measureText(label);
    const padding = 10;
    const boxWidth = metrics.width + padding * 2;
    const boxHeight = 28;

    let labelX = hw.pixelX;
    let labelY = hw.pixelY - 20;

    if (hw.isDragged) {
        labelX = hw.draggedX;
        labelY = hw.draggedY;

        // Draw red circle at original position
        ctx.fillStyle = '#FF0000';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(hw.originalPixelX || hw.pixelX, hw.originalPixelY || hw.pixelY, 8, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();

        // Draw bold red line
        ctx.strokeStyle = '#FF0000';
        ctx.lineWidth = 6;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(hw.originalPixelX || hw.pixelX, hw.originalPixelY || hw.pixelY);
        ctx.lineTo(labelX, labelY);
        ctx.stroke();
    } else {
        // Check for collision with site marker
        if (window.siteMarkerPosition) {
            const dist = Math.sqrt(
                Math.pow(labelX - window.siteMarkerPosition.x, 2) +
                Math.pow(labelY - window.siteMarkerPosition.y, 2)
            );

            if (dist < 80) {
                const angle = Math.atan2(
                    labelY - window.siteMarkerPosition.y,
                    labelX - window.siteMarkerPosition.x
                );

                labelX = window.siteMarkerPosition.x + Math.cos(angle) * 100;
                labelY = window.siteMarkerPosition.y + Math.sin(angle) * 100;

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(hw.pixelX, hw.pixelY);
                ctx.lineTo(labelX, labelY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
    }

    // Draw label box
    ctx.fillStyle = color;
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect(labelX - boxWidth / 2, labelY - boxHeight / 2, boxWidth, boxHeight, 6);
    ctx.fill();
    ctx.stroke();

    // Draw text
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, labelX, labelY);
}

/**
 * Draw individual POIs with collision avoidance
 */
export function drawIndividualPOIsEnhanced() {
    console.log('\nDrawing individual POIs with collision avoidance...');

    let drawnCount = 0;
    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        for (let idx = 0; idx < pois.length; idx++) {
            if (!selectedPOIs[category] || !selectedPOIs[category][idx]) continue;

            const poi = pois[idx];

            // Check if POI is in a cluster
            const isInCluster = poiClusters.some(cluster =>
                cluster.pois.some(p => p.poi === poi)
            );

            if (!isInCluster && isWithinMapBounds(poi.pixelX, poi.pixelY, MAP_WIDTH, MAP_HEIGHT)) {
                const collision = checkCollisionWithHighways(poi.pixelX, poi.pixelY, poi.logoSize / 2);

                if (collision.collides) {
                    const safePos = findSafePosition(poi.pixelX, poi.pixelY, poi.logoSize / 2);

                    if (safePos.adjusted) {
                        // Draw dotted line to original position
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(poi.pixelX, poi.pixelY);
                        ctx.lineTo(safePos.x, safePos.y);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Draw small green dot at original position
                        ctx.fillStyle = '#00FF00';
                        ctx.beginPath();
                        ctx.arc(poi.pixelX, poi.pixelY, 5, 0, 2 * Math.PI);
                        ctx.fill();

                        drawPOILogoStaticCached({ ...poi, pixelX: safePos.x, pixelY: safePos.y });
                    } else {
                        drawPOILogoStaticCached(poi);
                    }
                } else {
                    drawPOILogoStaticCached(poi);
                }

                drawnCount++;
            }
        }
    }

    console.log(`✓ Drew ${drawnCount} individual POIs with smart positioning`);
}

/**
 * Draw POI logo with caching
 */
export function drawPOILogoStaticCached(poi) {
    let x = poi.pixelX;
    let y = poi.pixelY;

    if (poi.isDragged) {
        x = poi.draggedX;
        y = poi.draggedY;

        // Draw red circle at original position
        ctx.fillStyle = '#FF0000';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(poi.originalPixelX || poi.pixelX, poi.originalPixelY || poi.pixelY, 8, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();

        // Draw bold red line to new position
        ctx.strokeStyle = '#FF0000';
        ctx.lineWidth = 6;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(poi.originalPixelX || poi.pixelX, poi.originalPixelY || poi.pixelY);
        ctx.lineTo(x, y);
        ctx.stroke();
    }

    const size = poi.logoSize || 40;

    if (!isWithinMapBounds(x, y, MAP_WIDTH, MAP_HEIGHT)) return;

    if (poi.logoUrl) {
        loadImageCached(poi.logoUrl).then(img => {
            // Calculate aspect ratio
            const imgAspect = img.width / img.height;
            let logoWidth = size;
            let logoHeight = size;
            
            if (imgAspect > 1) {
                logoHeight = size / imgAspect;
            } else {
                logoWidth = size * imgAspect;
            }

            // Calculate box dimensions with padding
            const boxPadding = 12;
            const boxWidth = logoWidth + (boxPadding * 2);
            const boxHeight = logoHeight + (boxPadding * 2);

            // Draw white rounded rectangle box
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(
                x - boxWidth / 2,
                y - boxHeight / 2,
                boxWidth,
                boxHeight,
                5
            );
            ctx.fill();
            ctx.stroke();

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Draw logo centered in box
            // Draw logo centered in box with 2px margin
            const margin = 2;
            ctx.drawImage(
                img, 
                x - (logoWidth - margin) / 2, 
                y - (logoHeight - margin) / 2, 
                logoWidth - margin, 
                logoHeight - margin
            );
        }).catch(() => {
            if (poi.category === 'popularLocations') {
                drawStarIcon(x, y, size);
            }
        });
    } else if (poi.category === 'popularLocations') {
        drawStarIcon(x, y, size);
    }
}

/**
 * Draw star icon for popular locations
 */
export function drawStarIcon(x, y, size) {
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x, y, size / 2 + 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.fillStyle = '#FFD700';
    ctx.font = `${size}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('⭐', x, y);
}

/**
 * Draw small star icon
 */
export function drawStarIconSmall(x, y, size) {
    ctx.fillStyle = '#FFD700';
    ctx.font = `${size}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('⭐', x, y);
}

/**
 * Clear logo cache
 */
export function clearLogoCache() {
    logoCache.clear();
}



















  js/user-analysis/resize-functionality.js




// ==================== RESIZE FUNCTIONALITY ====================
// js/user-analysis/resize-functionality.js

import {
    isResizeMode,
    resizedItem,
    mapCanvas,
    MAP_WIDTH,
    MAP_HEIGHT,
    poiClusters,
    allPOIsDataByCategory,
    selectedPOIs,
    highwayData,
    selectedHighways,
    selectedSiteLocation,
    permanentResizedSizes,
    setResizeMode,
    setResizedItem,
    updatePermanentResizedSizes,
    isDragMode
} from './state.js';
import { latLngToPixel } from './coordinates.js';
import { showNotification } from './utilities.js';
import { redrawStaticMapSmooth } from './main-render.js';
import { toggleDragMode } from './drag-functionality.js';

// Resize constraints
const MIN_SIZE = 20;
const MAX_SIZE = 150;
const MAX_CLUSTER_SIZE = 250;  // ⭐ NEW: Larger max for clusters
const RESIZE_STEP = 5;

/**
 * Toggle resize mode on/off
 */
export function toggleResizeMode() {
    const newMode = !isResizeMode;
    
    // Disable drag mode if it's active
    if (newMode && isDragMode) {
        toggleDragMode();
        showNotification('Drag mode disabled. Resize mode enabled.', 'info');
    }
    
    setResizeMode(newMode);

    const btn = document.getElementById('resizeModeBtn');
    const btnText = document.getElementById('resizeBtnText');
    const instructions = document.getElementById('resizeInstructions');

    // Disable/Enable other controls
    toggleOtherControls(!newMode);

    if (newMode) {
        // Enable resize mode
        btn.classList.add('active');
        btnText.textContent = 'Disable Resize Mode';
        instructions.classList.add('show');
        document.body.classList.add('resize-mode-active');

        // Add resize listeners to canvas
        mapCanvas.addEventListener('click', handleResizeClick);
        mapCanvas.addEventListener('wheel', handleResizeWheel, { passive: false });

        mapCanvas.style.cursor = 'pointer';  // ⭐ CHANGED: Use pointer instead

        console.log('✓ Resize mode ENABLED');
        showNotification('Resize mode enabled! Click on items to resize them, or use scroll wheel.', 'success');
    } else {
        // Disable resize mode
        btn.classList.remove('active');
        btnText.textContent = 'Enable Resize Mode';
        instructions.classList.remove('show');
        document.body.classList.remove('resize-mode-active');

        // Remove resize listeners
        mapCanvas.removeEventListener('click', handleResizeClick);
        mapCanvas.removeEventListener('wheel', handleResizeWheel);

        mapCanvas.style.cursor = 'default';
        setResizedItem(null);

        console.log('✓ Resize mode DISABLED');
        showNotification('Resize mode disabled', 'info');
    }
}

/**
 * Handle click to select item for resizing
 */
export function handleResizeClick(e) {
    if (!isResizeMode) return;

    const rect = mapCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const item = findItemAtPosition(mouseX, mouseY);
    
    if (item) {
        setResizedItem(item);
        showNotification(`Selected: ${item.type} - Use scroll wheel or +/- keys to resize`, 'info');
        console.log(`✓ Selected ${item.type} for resizing:`, item.name || item.data.name);
        
        // ⭐ CHANGED: Set cursor to resize when item selected
        mapCanvas.style.cursor = 'nwse-resize';
        
        // Add keyboard listeners for selected item
        document.addEventListener('keydown', handleResizeKeyboard);
    } else {
        setResizedItem(null);
        
        // ⭐ CHANGED: Reset cursor to pointer when deselected
        mapCanvas.style.cursor = 'pointer';
        
        document.removeEventListener('keydown', handleResizeKeyboard);
    }
    
    redrawStaticMapSmooth();
}

/**
 * Handle mouse wheel for resizing
 */
export function handleResizeWheel(e) {
    if (!isResizeMode || !resizedItem) return;

    e.preventDefault();
    
    // Throttle wheel events to prevent excessive redraws
    const now = Date.now();
    if (window.lastResizeTime && now - window.lastResizeTime < 50) {
        return; // Skip if less than 50ms since last resize
    }
    window.lastResizeTime = now;
    
    const delta = e.deltaY > 0 ? -RESIZE_STEP : RESIZE_STEP;
    resizeItem(resizedItem, delta);
}

/**
 * Handle keyboard for resizing
 */
export function handleResizeKeyboard(e) {
    if (!isResizeMode || !resizedItem) return;

    let delta = 0;
    
    if (e.key === '+' || e.key === '=') {
        delta = RESIZE_STEP;
    } else if (e.key === '-' || e.key === '_') {
        delta = -RESIZE_STEP;
    } else if (e.key === 'Escape') {
        setResizedItem(null);
        mapCanvas.style.cursor = 'pointer';
        document.removeEventListener('keydown', handleResizeKeyboard);
        showNotification('Deselected item', 'info');
        redrawStaticMapSmooth();
        return;
    }

    if (delta !== 0) {
        e.preventDefault();
        
        // Throttle keyboard events
        const now = Date.now();
        if (window.lastResizeTime && now - window.lastResizeTime < 50) {
            return;
        }
        window.lastResizeTime = now;
        
        resizeItem(resizedItem, delta);
    }
}

/**
 * Resize selected item
 */
function resizeItem(item, delta) {
    if (!item) return;

    if (item.type === 'cluster') {
        resizeCluster(item.data, delta);
    } else if (item.type === 'poi') {
        resizePOI(item.data, delta);
    } else if (item.type === 'highway') {
        resizeHighway(item.data, delta);
    } else if (item.type === 'siteMarker') {
        resizeSiteMarker(delta);
    }

    // Use requestAnimationFrame for smooth rendering
    if (!window.resizeAnimationFrame) {
        window.resizeAnimationFrame = requestAnimationFrame(() => {
            redrawStaticMapSmooth();
            window.resizeAnimationFrame = null;
        });
    }
}

/**
 * Resize cluster (affects all logos inside)
 */
function resizeCluster(cluster, delta) {
    // Get current size from permanent storage or cluster data
    let currentSize = cluster.size || 80;
    
    if (permanentResizedSizes.clusters[cluster.id]) {
        currentSize = permanentResizedSizes.clusters[cluster.id];
    }

    // ⭐ CHANGED: Use MAX_CLUSTER_SIZE instead of MAX_SIZE
    let newSize = Math.max(MIN_SIZE, Math.min(MAX_CLUSTER_SIZE, currentSize + delta));

    // Update cluster size
    cluster.size = newSize;

    // Update permanent storage
    updatePermanentResizedSizes('cluster', cluster.id, newSize);

    console.log(`Cluster ${cluster.id} resized to: ${newSize}px`);
     // Throttle notifications
    clearTimeout(window.resizeNotificationTimeout);
    window.resizeNotificationTimeout = setTimeout(() => {
        showNotification(`Cluster size: ${newSize}px`, 'info');
    }, 200);
}

/**
 * Resize individual POI
 */
function resizePOI(poi, delta) {
    let currentSize = poi.logoSize || 40;
    
    const key = `${poi.category}-${poi.id}`;
    if (permanentResizedSizes.pois[key]) {
        currentSize = permanentResizedSizes.pois[key];
    }

    let newSize = Math.max(MIN_SIZE, Math.min(MAX_SIZE, currentSize + delta));

    // Update POI size
    poi.logoSize = newSize;

    // Update permanent storage
    updatePermanentResizedSizes('poi', key, newSize);

    console.log(`POI ${poi.name} resized to: ${newSize}px`);
    
    clearTimeout(window.resizeNotificationTimeout);
    window.resizeNotificationTimeout = setTimeout(() => {
        showNotification(`${poi.name} size: ${newSize}px`, 'info');
    }, 200);
}


/**
 * Resize highway label
 */
function resizeHighway(hw, delta) {
    let currentSize = hw.labelSize || 14;
    
    const hwIndex = highwayData.indexOf(hw);
    if (permanentResizedSizes.highways[hwIndex]) {
        currentSize = permanentResizedSizes.highways[hwIndex];
    }

    let newSize = Math.max(10, Math.min(30, currentSize + delta));

    // Update highway label size
    hw.labelSize = newSize;

    // Update permanent storage
    updatePermanentResizedSizes('highway', hwIndex, newSize);

    console.log(`Highway ${hw.name} label resized to: ${newSize}px`);
    
    clearTimeout(window.resizeNotificationTimeout);
    window.resizeNotificationTimeout = setTimeout(() => {
        showNotification(`Highway label size: ${newSize}px`, 'info');
    }, 200);

}

/**
 * Resize site marker
 */
function resizeSiteMarker(delta) {
    let currentRadius = window.siteMarkerPosition?.radius || 20;
    
    if (permanentResizedSizes.siteMarker) {
        currentRadius = permanentResizedSizes.siteMarker;
    }

    let newRadius = Math.max(15, Math.min(50, currentRadius + delta));

    // Update site marker
    if (window.siteMarkerPosition) {
        window.siteMarkerPosition.radius = newRadius;
    }

    // Update permanent storage
    updatePermanentResizedSizes('siteMarker', null, newRadius);

    console.log(`Site marker resized to: ${newRadius}px`);
    
    clearTimeout(window.resizeNotificationTimeout);
    window.resizeNotificationTimeout = setTimeout(() => {
        showNotification(`Site marker size: ${newRadius}px`, 'info');
    }, 200);

}

/**
 * Find item at position for resizing
 */
function findItemAtPosition(x, y) {
    const clickRadius = 50;

    // Check site marker
    if (window.siteMarkerPosition) {
        let checkX, checkY;
        
        if (window.siteMarkerPosition.isDragged) {
            checkX = window.siteMarkerPosition.x;
            checkY = window.siteMarkerPosition.y;
        } else {
            const coords = latLngToPixel(selectedSiteLocation.lat, selectedSiteLocation.lng);
            checkX = coords.x;
            checkY = coords.y;
        }

        const dist = Math.sqrt(Math.pow(x - checkX, 2) + Math.pow(y - checkY, 2));

        if (dist < clickRadius) {
            return {
                type: 'siteMarker',
                name: 'Site Marker',
                data: window.siteMarkerPosition
            };
        }
    }

    // Check clusters
    for (let cluster of poiClusters) {
        let checkX = cluster.isDragged ? cluster.draggedX : cluster.clusterX;
        let checkY = cluster.isDragged ? cluster.draggedY : cluster.clusterY;

        const dist = Math.sqrt(Math.pow(x - checkX, 2) + Math.pow(y - checkY, 2));

        if (dist < clickRadius) {
            return {
                type: 'cluster',
                name: `Cluster (${cluster.pois.length} items)`,
                data: cluster
            };
        }
    }

    // Check individual POIs
    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        for (let idx = 0; idx < pois.length; idx++) {
            if (!selectedPOIs[category] || !selectedPOIs[category][idx]) continue;

            const poi = pois[idx];

            // Skip if in cluster
            const isInCluster = poiClusters.some(cluster =>
                cluster.pois.some(p => p.poi === poi)
            );
            if (isInCluster) continue;

            let checkX = poi.isDragged ? poi.draggedX : poi.pixelX;
            let checkY = poi.isDragged ? poi.draggedY : poi.pixelY;

            const dist = Math.sqrt(Math.pow(x - checkX, 2) + Math.pow(y - checkY, 2));

            if (dist < clickRadius) {
                return {
                    type: 'poi',
                    name: poi.name,
                    data: poi
                };
            }
        }
    }

    // Check highways
    for (let idx = 0; idx < highwayData.length; idx++) {
        if (!selectedHighways[idx]) continue;

        const hw = highwayData[idx];
        let checkX = hw.isDragged ? hw.draggedX : hw.pixelX;
        let checkY = hw.isDragged ? hw.draggedY : hw.pixelY;

        const dist = Math.sqrt(Math.pow(x - checkX, 2) + Math.pow(y - checkY, 2));

        if (dist < clickRadius) {
            return {
                type: 'highway',
                name: hw.name,
                data: hw
            };
        }
    }

    return null;
}

/**
 * Toggle other controls (disable during resize mode)
 */
function toggleOtherControls(enabled) {
    // Disable/Enable drag mode button
    const dragBtn = document.getElementById('dragModeBtn');
    if (dragBtn) {
        dragBtn.disabled = !enabled;
        if (!enabled) {
            dragBtn.style.opacity = '0.5';
            dragBtn.style.cursor = 'not-allowed';
        } else {
            dragBtn.style.opacity = '1';
            dragBtn.style.cursor = 'pointer';
        }
    }

    // Disable/Enable all checkboxes in right panel
    const checkboxes = document.querySelectorAll('.panel-content input[type="checkbox"]');
    checkboxes.forEach(cb => {
        cb.disabled = !enabled;
    });

    console.log(`Other controls ${enabled ? 'enabled' : 'disabled'}`);
}

/**
 * Restore resized sizes after redraw
 */
export function restoreResizedSizes() {
    console.log('Restoring resized sizes...');

    // Restore POIs
    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        pois.forEach(poi => {
            const key = `${category}-${poi.id}`;
            if (permanentResizedSizes.pois[key]) {
                poi.logoSize = permanentResizedSizes.pois[key];
            }
        });
    }

    // Restore clusters
    poiClusters.forEach(cluster => {
        if (permanentResizedSizes.clusters[cluster.id]) {
            cluster.size = permanentResizedSizes.clusters[cluster.id];
        }
    });

    // Restore highways
    highwayData.forEach((hw, index) => {
        if (permanentResizedSizes.highways[index]) {
            hw.labelSize = permanentResizedSizes.highways[index];
        }
    });

    // Restore site marker
    if (permanentResizedSizes.siteMarker && window.siteMarkerPosition) {
        window.siteMarkerPosition.radius = permanentResizedSizes.siteMarker;
    }

    console.log('✓ Resized sizes restored');
}

/**
 * Reset all sizes to default
 */
export function resetAllSizes() {
    if (!confirm('Reset all item sizes to default?')) return;

    // Clear permanent storage
    permanentResizedSizes.pois = {};
    permanentResizedSizes.clusters = {};
    permanentResizedSizes.highways = {};
    permanentResizedSizes.siteMarker = null;

    // Reset POIs
    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        pois.forEach(poi => {
            poi.logoSize = 40;
        });
    }

    // Reset clusters
    poiClusters.forEach(cluster => {
        cluster.size = 80;
    });

    // Reset highways
    highwayData.forEach(hw => {
        hw.labelSize = 14;
    });

    // Reset site marker
    if (window.siteMarkerPosition) {
        window.siteMarkerPosition.radius = 20;
    }

    showNotification('All sizes reset to default', 'success');
    redrawStaticMapSmooth();
}

/**
 * Setup global resize functions
 */
export function setupGlobalResizeFunctions() {
    window.toggleResizeMode = toggleResizeMode;
    window.resetAllSizes = resetAllSizes;
}















   js/user-analysis/state.js 




// ==================== GLOBAL STATE MANAGEMENT ====================

// Analysis parameters
export let analysisParams = null;
export let selectedSiteLocation = null;
export let rectangleBounds = null;

// Data storage
export let allPOIsDataByCategory = {};
export let highwayData = [];

// Canvas references
export let mapCanvas = null;
export let ctx = null;

// Map projection
export let MAP_WIDTH = 0;
export let MAP_HEIGHT = 0;

// Selection tracking
export let selectedPOIs = {};
export let selectedHighways = [];

// Clustering
export let poiClusters = [];

// Drag mode state
export let isDragMode = false;
export let draggedItem = null;
export let dragStartX = 0;
export let dragStartY = 0;
export let dragOffsetX = 0;
export let dragOffsetY = 0;

// Permanent dragged positions storage
export let permanentDraggedPositions = {
    pois: {},
    clusters: {},
    highways: {},
    siteMarker: null
};

// ==================== ADD RESIZE MODE STATE HERE ====================

// Resize mode state
export let isResizeMode = false;
export let resizedItem = null;

// Permanent resized sizes storage
export let permanentResizedSizes = {
    pois: {},        // key: "category-id", value: size
    clusters: {},    // key: cluster.id, value: size
    highways: {},    // key: index, value: labelSize
    siteMarker: null // value: radius
};

// ==================== END RESIZE MODE STATE ====================

// Original positions for reset
export let originalPositions = {
    clusters: [],
    pois: {},
    highways: [],
    siteMarker: null
};

// Setters for state updates
export function setAnalysisParams(params) {
    analysisParams = params;
}

export function setSelectedSiteLocation(location) {
    selectedSiteLocation = location;
}

export function setRectangleBounds(bounds) {
    rectangleBounds = bounds;
}

export function setAllPOIsDataByCategory(data) {
    allPOIsDataByCategory = data;
}

export function setHighwayData(data) {
    highwayData = data;
}

export function setMapCanvas(canvas) {
    mapCanvas = canvas;
}

export function setMapContext(context) {
    ctx = context;
}

export function setMapDimensions(width, height) {
    MAP_WIDTH = width;
    MAP_HEIGHT = height;
}

export function setSelectedPOIs(pois) {
    selectedPOIs = pois;
}

export function setSelectedHighways(highways) {
    selectedHighways = highways;
}

export function setPOIClusters(clusters) {
    poiClusters = clusters;
}

export function setDragMode(mode) {
    isDragMode = mode;
}

export function setDraggedItem(item) {
    draggedItem = item;
}

export function setDragCoordinates(startX, startY, offsetX, offsetY) {
    dragStartX = startX;
    dragStartY = startY;
    dragOffsetX = offsetX;
    dragOffsetY = offsetY;
}

// ==================== ADD RESIZE SETTERS HERE ====================

export function setResizeMode(mode) {
    isResizeMode = mode;
}

export function setResizedItem(item) {
    resizedItem = item;
}

export function updatePermanentResizedSizes(type, key, size) {
    if (type === 'poi') {
        permanentResizedSizes.pois[key] = size;
    } else if (type === 'cluster') {
        permanentResizedSizes.clusters[key] = size;
    } else if (type === 'highway') {
        permanentResizedSizes.highways[key] = size;
    } else if (type === 'siteMarker') {
        permanentResizedSizes.siteMarker = size;
    }
}

export function clearPermanentResizedSize(type, key) {
    if (type === 'poi') {
        delete permanentResizedSizes.pois[key];
    } else if (type === 'cluster') {
        delete permanentResizedSizes.clusters[key];
    } else if (type === 'highway') {
        delete permanentResizedSizes.highways[key];
    } else if (type === 'siteMarker') {
        permanentResizedSizes.siteMarker = null;
    }
}

// ==================== END RESIZE SETTERS ====================

export function updatePermanentDraggedPositions(type, key, position) {
    if (type === 'poi') {
        permanentDraggedPositions.pois[key] = position;
    } else if (type === 'cluster') {
        permanentDraggedPositions.clusters[key] = position;
    } else if (type === 'highway') {
        permanentDraggedPositions.highways[key] = position;
    } else if (type === 'siteMarker') {
        permanentDraggedPositions.siteMarker = position;
    }
}

export function clearPermanentDraggedPosition(type, key) {
    if (type === 'poi') {
        delete permanentDraggedPositions.pois[key];
    } else if (type === 'cluster') {
        delete permanentDraggedPositions.clusters[key];
    } else if (type === 'highway') {
        delete permanentDraggedPositions.highways[key];
    } else if (type === 'siteMarker') {
        permanentDraggedPositions.siteMarker = null;
    }
}



















   js/user-analysis/ui-updates.js 






// ==================== UI PANEL UPDATES ====================

import { 
    selectedSiteLocation, 
    analysisParams, 
    allPOIsDataByCategory,
    highwayData,
    selectedPOIs,
    selectedHighways,
    rectangleBounds,
    clearPermanentDraggedPosition
} from './state.js';
import { categoryIcons } from './constants.js';
import { getHighwayColor, categorizeRoute, showNotification } from './utilities.js';
import { calculateAllPixelCoordinates } from './coordinates.js';
import { createPOIClusters } from './clustering.js';
import { restoreDraggedPositions } from './drag-functionality.js';
import { redrawStaticMapSmooth } from './main-render.js';
import { isDragMode } from './state.js';

/**
 * Update all info panels with current data
 */
export function updateInfoPanels() {
    document.getElementById('locationInfo').innerHTML = `
        <strong>Address:</strong> ${selectedSiteLocation.address}<br>
        <strong>Coordinates:</strong> ${selectedSiteLocation.lat.toFixed(6)}, ${selectedSiteLocation.lng.toFixed(6)}
    `;

    document.getElementById('searchArea').innerHTML = `
        <strong>Radius:</strong> ${analysisParams.radius} miles
    `;

    const poiSectionsContainer = document.getElementById('poiSections');
    poiSectionsContainer.innerHTML = '';

    for (const [category, pois] of Object.entries(allPOIsDataByCategory)) {
        if (pois.length === 0) continue;

        const section = document.createElement('div');
        section.className = 'poi-category-section';
        section.innerHTML = `<h4>${categoryIcons[category]} ${category.replace(/_/g, ' ').toUpperCase()}</h4>`;

        const list = document.createElement('ul');
        list.className = 'poi-list';

        pois.forEach((poi, idx) => {
            const categoryLabel = (category === 'popularLocations') ? 
                ' <span style="background: #666; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.7rem; margin-left: 5px;">(Landmark)</span>' : '';

            const li = document.createElement('li');
            li.innerHTML = `
                <input type="checkbox" 
                       data-category="${category}" 
                       data-index="${idx}"
                       ${selectedPOIs[category][idx] ? 'checked' : ''} 
                       onchange="togglePOI('${category}', ${idx}, this.checked)">
                ${poi.logoUrl ? `<img class="poi-logo" src="${poi.logoUrl}" alt="${poi.name}">` : '⭐'}
                ${idx + 1}. ${poi.name}${categoryLabel}: ${poi.distanceMiles.toFixed(2)} mi
            `;
            list.appendChild(li);
        });

        section.appendChild(list);
        poiSectionsContainer.appendChild(section);
    }

    if (highwayData.length > 0) {
        const highwaySection = document.createElement('div');
        highwaySection.className = 'highway-section';
        highwaySection.innerHTML = `<h4>🛣️ Main Routes & Highways</h4>`;

        const list = document.createElement('ul');
        list.className = 'poi-list';

        highwayData.forEach((hw, idx) => {
            const color = getHighwayColor(hw.type);
            const li = document.createElement('li');
            li.innerHTML = `
                <input type="checkbox" 
                       data-index="${idx}"
                       ${selectedHighways[idx] ? 'checked' : ''} 
                       onchange="toggleHighway(${idx}, this.checked)">
                <span class="route-badge" style="background: ${color};">${hw.ref || hw.name.substring(0, 3).toUpperCase()}</span>
                ${hw.name} (${categorizeRoute(hw.type)}): ${hw.distanceMiles.toFixed(2)} mi
            `;
            list.appendChild(li);
        });

        highwaySection.appendChild(list);
        document.getElementById('highwaySection').appendChild(highwaySection);
    }
}

/**
 * Toggle POI visibility
 */
export function togglePOI(category, index, checked) {
    // Don't allow toggling during drag mode
    if (isDragMode) {
        showNotification('Please disable drag mode first', 'warning');
        // Revert checkbox state
        setTimeout(() => {
            const checkbox = document.querySelector(`#poiSections input[type="checkbox"][data-category="${category}"][data-index="${index}"]`);
            if (checkbox) checkbox.checked = !checked;
        }, 0);
        return;
    }

    selectedPOIs[category][index] = checked;

    const poi = allPOIsDataByCategory[category][index];
    
    if (!checked) {
        // Remove from permanent storage if unchecked
        const key = `${category}-${poi.id}`;
        clearPermanentDraggedPosition('poi', key);
    }

    // Recalculate clusters but restore positions after
    calculateAllPixelCoordinates();
    createPOIClusters();
    restoreDraggedPositions();
    redrawStaticMapSmooth();
}

/**
 * Toggle highway visibility
 */
export function toggleHighway(index, checked) {
    // Don't allow toggling during drag mode
    if (isDragMode) {
        showNotification('Please disable drag mode first', 'warning');
        // Revert checkbox state
        setTimeout(() => {
            const checkbox = document.querySelector(`#highwaySection input[type="checkbox"][data-index="${index}"]`);
            if (checkbox) checkbox.checked = !checked;
        }, 0);
        return;
    }

    selectedHighways[index] = checked;

    if (!checked) {
        clearPermanentDraggedPosition('highway', index);
    }

    restoreDraggedPositions();
    redrawStaticMapSmooth();
}

/**
 * Make toggle functions globally available
 */
export function setupGlobalToggleFunctions() {
    window.togglePOI = togglePOI;
    window.toggleHighway = toggleHighway;
}
















   js/user-analysis/utilities.js



// ==================== UTILITY FUNCTIONS ====================

/**
 * Calculate distance between two coordinates using Haversine formula
 */
export function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

/**
 * Delay execution for specified milliseconds
 */
export function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Load image with cross-origin support
 */
export function loadImage(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
    });
}

/**
 * Get highway color based on type
 */
export function getHighwayColor(type) {
    switch (type) {
        case 'motorway': return '#E60000';
        case 'trunk': return '#FF8C00';
        case 'primary': return '#0066FF';
        case 'tertiary': return '#9933FF';
        default: return '#808080';
    }
}

/**
 * Categorize route type to human-readable format
 */
export function categorizeRoute(type) {
    switch (type) {
        case 'motorway': return 'Highway';
        case 'trunk': return 'Expressway';
        case 'primary': return 'Main Road';
        case 'tertiary': return 'Local Road';
        default: return type.charAt(0).toUpperCase() + type.slice(1);
    }
}

/**
 * Format address from OSM tags
 */
export function formatAddress(tags) {
    const parts = [
        tags['addr:housenumber'],
        tags['addr:street'],
        tags['addr:city'],
        tags['addr:state'],
        tags['addr:postcode']
    ].filter(Boolean);
    return parts.length > 0 ? parts.join(', ') : 'N/A';
}

/**
 * Show notification message
 */
export function showNotification(message, type = 'info') {
    const existing = document.querySelector('.notification');
    if (existing) existing.remove();

    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        padding: 1rem 1.5rem;
        background: ${type === 'success' ? '#28a745' : 
                      type === 'error' ? '#dc3545' : 
                      type === 'warning' ? '#ffc107' : '#17a2b8'};
        color: white;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        z-index: 10000;
        animation: slideIn 0.3s ease;
    `;
    notification.innerHTML = `
        <i class="fas ${type === 'success' ? 'fa-check-circle' : 
                        type === 'error' ? 'fa-exclamation-circle' : 
                        type === 'warning' ? 'fa-exclamation-triangle' :
                        'fa-info-circle'}"></i>
        <span style="margin-left: 10px;">${message}</span>
    `;

    document.body.appendChild(notification);

    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

/**
 * Check if point is within map bounds
 */
export function isWithinMapBounds(x, y, MAP_WIDTH, MAP_HEIGHT) {
    return x >= 0 && x <= MAP_WIDTH && y >= 0 && y <= MAP_HEIGHT;
}

/**
 * Debounce function for performance optimization
 */
export function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

/**
 * Add roundRect support for older browsers
 */
export function polyfillRoundRect() {
    if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
            if (width < 2 * radius) radius = width / 2;
            if (height < 2 * radius) radius = height / 2;
            this.beginPath();
            this.moveTo(x + radius, y);
            this.arcTo(x + width, y, x + width, y + height, radius);
            this.arcTo(x + width, y + height, x, y + height, radius);
            this.arcTo(x, y + height, x, y, radius);
            this.arcTo(x, y, x + width, y, radius);
            this.closePath();
            return this;
        };
    }












 js/user-analysis/pdf-export.js 






 // ==================== PDF EXPORT - MAIN ENTRY POINT ====================
// js/user-analysis/pdf-export.js

import { exportPDFEnhanced } from './pdf-export-folder/JS/pdf-export-main.js';
import { mapCanvas, selectedSiteLocation } from './state.js';

/**
 * Setup global export function
 * This is called from user-analysis.js during initialization
 */
export function setupGlobalExportFunction() {
    window.exportPDF = async () => {
        await exportPDFEnhanced(mapCanvas, selectedSiteLocation);
    };
    
    console.log('✅ PDF export function registered globally');
}


















js\user-analysis\pdf-export-folder\Html



footer-form-template.js



// ==================== PDF FOOTER FORM HTML TEMPLATE ====================
// js/user-analysis/pdf-export-folder/Html/footer-form-template.js

/**
 * Create the HTML structure for the PDF footer form
 * @returns {string} HTML string for the form
 */
export function createFormHTML() {
    return `
        <div class="pdf-form-wrapper">
            <!-- Header Section -->
            <div class="pdf-form-header">
                <h2>
                    <i class="fas fa-file-pdf"></i>
                    Customize Your PDF Report
                </h2>
                <p>Add professional details to your exported report</p>
            </div>

            <!-- Form Content with Scroll -->
            <div class="pdf-form-content">
                <div class="pdf-form-grid">
                    <!-- Agent 1 Section -->
                    <div class="pdf-form-section agent-1">
                        <div class="pdf-section-header">
                            <div class="pdf-section-icon">1</div>
                            <h3 class="pdf-section-title">Primary Agent</h3>
                        </div>
                        
                        <div class="pdf-form-group">
                            <label class="pdf-form-label">Full Name</label>
                            <div class="pdf-input-container">
                                <input 
                                    type="text" 
                                    id="agent1-name" 
                                    class="pdf-form-input"
                                    placeholder="Enter agent's full name"
                                >
                                <i class="fas fa-user"></i>
                            </div>
                        </div>
                        
                        <div class="pdf-form-group">
                            <label class="pdf-form-label">Office Number</label>
                            <div class="pdf-input-container">
                                <input 
                                    type="text" 
                                    id="agent1-phone" 
                                    class="pdf-form-input"
                                    placeholder="(999) 999-9999"
                                >
                                <i class="fas fa-phone"></i>
                            </div>
                        </div>
                        
                        <div class="pdf-form-group">
                            <label class="pdf-form-label">Email Address</label>
                            <div class="pdf-input-container">
                                <input 
                                    type="email" 
                                    id="agent1-email" 
                                    class="pdf-form-input"
                                    placeholder="agent@example.com"
                                >
                                <i class="fas fa-envelope"></i>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Agent 2 Section -->
                    <div class="pdf-form-section agent-2">
                        <div class="pdf-section-header">
                            <div class="pdf-section-icon">2</div>
                            <h3 class="pdf-section-title">Secondary Agent (Optional)</h3>
                        </div>
                        
                        <div class="pdf-form-group">
                            <label class="pdf-form-label">Full Name</label>
                            <div class="pdf-input-container">
                                <input 
                                    type="text" 
                                    id="agent2-name" 
                                    class="pdf-form-input"
                                    placeholder="Enter agent's full name (optional)"
                                >
                                <i class="fas fa-user"></i>
                            </div>
                        </div>
                        
                        <div class="pdf-form-group">
                            <label class="pdf-form-label">Office Number</label>
                            <div class="pdf-input-container">
                                <input 
                                    type="text" 
                                    id="agent2-phone" 
                                    class="pdf-form-input"
                                    placeholder="(999) 999-9999 (optional)"
                                >
                                <i class="fas fa-phone"></i>
                            </div>
                        </div>
                        
                        <div class="pdf-form-group">
                            <label class="pdf-form-label">Email Address</label>
                            <div class="pdf-input-container">
                                <input 
                                    type="email" 
                                    id="agent2-email" 
                                    class="pdf-form-input"
                                    placeholder="agent@example.com (optional)"
                                >
                                <i class="fas fa-envelope"></i>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Location Address Section -->
                    <div class="pdf-form-section location">
                        <div class="pdf-section-header">
                            <div class="pdf-section-icon">
                                <i class="fas fa-map-marker-alt"></i>
                            </div>
                            <h3 class="pdf-section-title">Location Address</h3>
                        </div>
                        
                        <div class="pdf-form-group">
                            <label class="pdf-form-label">Location Name</label>
                            <div class="pdf-input-container">
                                <input 
                                    type="text" 
                                    id="location-name" 
                                    class="pdf-form-input"
                                    placeholder="Property or Business Name"
                                >
                                <i class="fas fa-building"></i>
                            </div>
                        </div>
                        
                        <div class="pdf-form-group">
                            <label class="pdf-form-label">Full Address</label>
                            <div class="pdf-input-container">
                                <textarea 
                                    id="location-address" 
                                    rows="4" 
                                    class="pdf-form-input"
                                    placeholder="123 Main Street, City, State ZIP"
                                ></textarea>
                                <i class="fas fa-map-marked-alt"></i>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer Buttons -->
            <div class="pdf-form-footer">
                <div class="pdf-form-info">
                    <i class="fas fa-info-circle"></i>
                    <span>Agent 2 is optional. Leave fields empty if not needed.</span>
                </div>
                <div class="pdf-form-buttons">
                    <button id="form-cancel" class="pdf-form-button pdf-form-cancel">
                        <i class="fas fa-times"></i> 
                        Cancel
                    </button>
                    <button id="form-submit" class="pdf-form-button pdf-form-submit">
                        <i class="fas fa-check"></i> 
                        Generate PDF
                    </button>
                </div>
            </div>
        </div>
    `;
}



























js\user-analysis\pdf-export-folder\CSS


js\user-analysis\pdf-export-folder\CSS\footer-form-styles.css




/* ==================== PDF FOOTER FORM STYLES ==================== */
/* js/user-analysis/pdf-export-folder/CSS/footer-form-styles.css */

#pdf-footer-form-container {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

.pdf-form-wrapper {
    background: white;
    width: 90%;
    max-width: 1100px;
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    height: 90vh;
    max-height: 900px;
    animation: slideUp 0.4s ease;
}

@keyframes slideUp {
    from {
        transform: translateY(50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

/* Header Section */
.pdf-form-header {
    background: linear-gradient(135deg, #8B0000 0%, #C41E3A 50%, #8B0000 100%);
    padding: 30px 40px;
    text-align: center;
    color: white;
    position: relative;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
}

.pdf-form-header::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: url('data:image/svg+xml,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse"><path d="M 20 0 L 0 0 0 20" fill="none" stroke="rgba(255,255,255,0.05)" stroke-width="1"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
    opacity: 0.3;
}

.pdf-form-header h2 {
    margin: 0;
    font-weight: 600;
    font-size: 28px;
    letter-spacing: 0.5px;
    position: relative;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

.pdf-form-header h2 i {
    margin-right: 12px;
    font-size: 26px;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.1);
    }
}

.pdf-form-header p {
    margin: 10px 0 0 0;
    opacity: 0.95;
    font-size: 16px;
    position: relative;
}

/* Form Content Area */
.pdf-form-content {
    flex: 1;
    padding: 35px;
    overflow-y: auto;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
}

.pdf-form-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 30px;
}

/* Section Cards */
.pdf-form-section {
    background: white;
    border-radius: 16px;
    padding: 28px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    border: 2px solid transparent;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.pdf-form-section::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, var(--section-color) 0%, transparent 100%);
    transform: scaleX(0);
    transform-origin: left;
    transition: transform 0.3s ease;
}

.pdf-form-section:hover::before {
    transform: scaleX(1);
}

.pdf-form-section:hover {
    transform: translateY(-5px);
    box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
    border-color: var(--section-color);
}

/* Agent 1 Styling */
.pdf-form-section.agent-1 {
    --section-color: #8B0000;
}

/* Agent 2 Styling */
.pdf-form-section.agent-2 {
    --section-color: #6c757d;
}

/* Location Styling */
.pdf-form-section.location {
    --section-color: #28a745;
}

/* Section Header */
.pdf-section-header {
    display: flex;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 18px;
    border-bottom: 3px solid var(--section-color);
}

.pdf-section-icon {
    width: 48px;
    height: 48px;
    background: var(--section-color);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 15px;
    color: white;
    font-weight: bold;
    flex-shrink: 0;
    font-size: 20px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    transition: transform 0.3s ease;
}

.pdf-form-section:hover .pdf-section-icon {
    transform: rotate(360deg) scale(1.1);
}

.pdf-section-title {
    color: var(--section-color);
    margin: 0;
    font-size: 20px;
    font-weight: 600;
    letter-spacing: 0.3px;
}

/* Form Groups */
.pdf-form-group {
    margin-bottom: 22px;
}

.pdf-form-group:last-child {
    margin-bottom: 0;
}

.pdf-form-label {
    display: block;
    margin-bottom: 10px;
    font-weight: 600;
    color: #333;
    font-size: 14px;
    letter-spacing: 0.3px;
    text-transform: uppercase;
}

/* Input Container */
.pdf-input-container {
    position: relative;
}

.pdf-input-container i {
    position: absolute;
    left: 16px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--section-color);
    font-size: 16px;
    transition: all 0.3s ease;
}

.pdf-input-container textarea + i {
    top: 18px;
    transform: none;
}

/* Input Fields */
.pdf-form-input {
    width: 100%;
    padding: 14px 14px 14px 46px;
    border: 2px solid #ddd;
    border-radius: 10px;
    font-size: 15px;
    transition: all 0.3s ease;
    background: #fafafa;
    font-family: inherit;
}

.pdf-form-input:focus {
    outline: none;
    border-color: var(--section-color);
    box-shadow: 0 0 0 4px rgba(var(--section-color-rgb), 0.1);
    background: white;
}

.pdf-form-input:focus + i {
    color: var(--section-color);
    transform: translateY(-50%) scale(1.1);
}

textarea.pdf-form-input {
    resize: vertical;
    min-height: 110px;
    padding-top: 14px;
}

/* Footer Buttons Area */
.pdf-form-footer {
    background: white;
    padding: 25px 35px;
    border-top: 2px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.05);
}

.pdf-form-info {
    display: flex;
    align-items: center;
    color: #666;
    font-size: 14px;
    font-weight: 500;
}

.pdf-form-info i {
    margin-right: 10px;
    color: #8B0000;
    font-size: 18px;
}

.pdf-form-buttons {
    display: flex;
    gap: 15px;
}

/* Buttons */
.pdf-form-button {
    border: none;
    padding: 14px 32px;
    border-radius: 10px;
    font-weight: 600;
    font-size: 15px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    align-items: center;
    gap: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
}

.pdf-form-button i {
    font-size: 16px;
}

.pdf-form-cancel {
    background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
    color: white;
}

.pdf-form-cancel:hover {
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4);
}

.pdf-form-submit {
    background: linear-gradient(135deg, #8B0000 0%, #C41E3A 100%);
    color: white;
}

.pdf-form-submit:hover {
    background: linear-gradient(135deg, #A52A2A 0%, #8B0000 100%);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(139, 0, 0, 0.5);
}

.pdf-form-button:active {
    transform: translateY(0);
}

/* Scrollbar Styling */
.pdf-form-content::-webkit-scrollbar {
    width: 10px;
}

.pdf-form-content::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 5px;
}

.pdf-form-content::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #8B0000 0%, #C41E3A 100%);
    border-radius: 5px;
}

.pdf-form-content::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #A52A2A 0%, #8B0000 100%);
}

/* Animation for form sections */
@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.pdf-form-section {
    animation: fadeInUp 0.6s ease forwards;
}

.pdf-form-section:nth-child(1) {
    animation-delay: 0.1s;
}

.pdf-form-section:nth-child(2) {
    animation-delay: 0.2s;
}

.pdf-form-section:nth-child(3) {
    animation-delay: 0.3s;
}

/* Color Variables */
.agent-1 {
    --section-color-rgb: 139, 0, 0;
}

.agent-2 {
    --section-color-rgb: 108, 117, 125;
}

.location {
    --section-color-rgb: 40, 167, 69;
}

/* Responsive Design */
@media (max-width: 768px) {
    .pdf-form-wrapper {
        width: 95%;
        height: 95vh;
    }
    
    .pdf-form-grid {
        grid-template-columns: 1fr;
        gap: 20px;
    }
    
    .pdf-form-footer {
        flex-direction: column;
        gap: 15px;
    }
    
    .pdf-form-buttons {
        width: 100%;
    }
    
    .pdf-form-button {
        flex: 1;
        justify-content: center;
    }
}









js\user-analysis\pdf-export-folder\JS




js\user-analysis\pdf-export-folder\JS\census-data-fetcher.js






// ==================== CENSUS DATA FETCHER ====================
// js/user-analysis/pdf-export-folder/JS/census-data-fetcher.js

import { getDistanceInMiles, aggregateData } from './pdf-helpers.js';

const CENSUS_API_KEY = 'f51b9aea95c15ea41fcdb2208d47feb3bf8b6c2a';

/**
 * Fetch census data by radius
 * @param {number} lat - Latitude
 * @param {number} lon - Longitude
 * @returns {Promise<Object>} Census data for 1, 3, and 5 mile radii
 */
export async function getCensusDataByRadius(lat, lon) {
    console.log(`Fetching census data for location: ${lat}, ${lon}...`);
    
    try {
        // Step 1: Get state and county FIPS codes
        const geoUrl = `https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/tigerWMS_Current/MapServer/8/query?geometry=${lon},${lat}&geometryType=esriGeometryPoint&inSR=4326&spatialRel=esriSpatialRelIntersects&outFields=STATE,COUNTY,TRACT&returnGeometry=false&f=json`;
        
        const geoResponse = await fetch(geoUrl);
        const geoData = await geoResponse.json();
        
        if (!geoData.features || geoData.features.length === 0) {
            throw new Error('Location not found or outside U.S. Census coverage');
        }
        
        const stateFips = geoData.features[0].attributes.STATE;
        const countyFips = geoData.features[0].attributes.COUNTY;
        
        // Step 2: Get all tracts in the county with their centroids
        const tigerUrl = `https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/tigerWMS_Current/MapServer/8/query?where=STATE='${stateFips}'+AND+COUNTY='${countyFips}'&outFields=STATE,COUNTY,TRACT,CENTLAT,CENTLON&returnGeometry=false&f=json`;
        
        const tigerResponse = await fetch(tigerUrl);
        const tigerData = await tigerResponse.json();
        
        if (!tigerData.features) {
            throw new Error('Could not fetch tract geometry');
        }
        
        // Step 3: Filter tracts by distance
        const tracts1Mile = [];
        const tracts3Mile = [];
        const tracts5Mile = [];
        
        tigerData.features.forEach(feature => {
            const tractLat = parseFloat(feature.attributes.CENTLAT);
            const tractLon = parseFloat(feature.attributes.CENTLON);
            const distance = getDistanceInMiles(lat, lon, tractLat, tractLon);
            const geoid = feature.attributes.STATE + feature.attributes.COUNTY + feature.attributes.TRACT;
            
            if (distance <= 1) tracts1Mile.push(geoid);
            if (distance <= 3) tracts3Mile.push(geoid);
            if (distance <= 5) tracts5Mile.push(geoid);
        });
        
        console.log(`Found tracts: 1-mile: ${tracts1Mile.length}, 3-mile: ${tracts3Mile.length}, 5-mile: ${tracts5Mile.length}`);
        
        // Step 4: Fetch ACS data for all tracts in the county
        const variables = 'B01003_001E,B01001_002E,B01001_026E,B19013_001E,B11001_001E,B25077_001E,B25003_002E,B01002_001E,B01002_002E,B01002_003E,B25010_001E';
        const acsUrl = `https://api.census.gov/data/2022/acs/acs5?get=${variables}&for=tract:*&in=state:${stateFips}&in=county:${countyFips}&key=${CENSUS_API_KEY}`;
        
        const acsResponse = await fetch(acsUrl);
        const acsData = await acsResponse.json();
        
        if (!acsData || acsData.length < 2) {
            throw new Error('No ACS data returned');
        }
        
        // Step 5: Parse ACS data into a map
        const header = acsData[0];
        const dataMap = new Map();
        
        for (let i = 1; i < acsData.length; i++) {
            const row = acsData[i];
            const tractGeoid = row[header.indexOf('state')] + 
                              row[header.indexOf('county')] + 
                              row[header.indexOf('tract')];
            
            dataMap.set(tractGeoid, {
                pop: parseInt(row[header.indexOf('B01003_001E')] || 0),
                male: parseInt(row[header.indexOf('B01001_002E')] || 0),
                female: parseInt(row[header.indexOf('B01001_026E')] || 0),
                income: parseInt(row[header.indexOf('B19013_001E')] || 0),
                households: parseInt(row[header.indexOf('B11001_001E')] || 0),
                homeValue: parseInt(row[header.indexOf('B25077_001E')] || 0),
                owners: parseInt(row[header.indexOf('B25003_002E')] || 0),
                medianAge: parseFloat(row[header.indexOf('B01002_001E')] || 0),
                medianAgeMale: parseFloat(row[header.indexOf('B01002_002E')] || 0),
                medianAgeFemale: parseFloat(row[header.indexOf('B01002_003E')] || 0),
                avgHHSize: parseFloat(row[header.indexOf('B25010_001E')] || 0)
            });
        }
        
        // Step 6: Aggregate data for each radius
        return {
            '1_mile': aggregateData(tracts1Mile, dataMap),
            '3_mile': aggregateData(tracts3Mile, dataMap),
            '5_mile': aggregateData(tracts5Mile, dataMap)
        };
        
    } catch (error) {
        console.error('Census data error:', error);
        throw error;
    }
}

/**
 * Get sample census data (fallback)
 * @returns {Object} Sample census data
 */
export function getSampleCensusData() {
    console.warn('Using sample census data');
    return {
        '1_mile': { 
            population: 12500, 
            male: 6100, 
            female: 6400, 
            households: 4800, 
            avg_median_income: 68500, 
            avg_median_home_value: 285000,
            avg_age: 38.5, 
            avg_age_male: 37.2, 
            avg_age_female: 39.8, 
            avg_hh_size: 2.6
        },
        '3_mile': { 
            population: 45800, 
            male: 22400, 
            female: 23400, 
            households: 18200, 
            avg_median_income: 72300, 
            avg_median_home_value: 310000,
            avg_age: 39.2, 
            avg_age_male: 38.1, 
            avg_age_female: 40.3, 
            avg_hh_size: 2.5
        },
        '5_mile': { 
            population: 128000, 
            male: 62500, 
            female: 65500, 
            households: 52000, 
            avg_median_income: 75800, 
            avg_median_home_value: 335000,
            avg_age: 40.1, 
            avg_age_male: 38.9, 
            avg_age_female: 41.2, 
            avg_hh_size: 2.5
        }
    };
}























js\user-analysis\pdf-export-folder\JS\footer-form-controller.js







// ==================== PDF FOOTER FORM CONTROLLER ====================
// js/user-analysis/pdf-export-folder/JS/footer-form-controller.js

import { createFormHTML } from '../Html/footer-form-template.js';

/**
 * Create and show the PDF footer form
 * @returns {Promise} Promise that resolves with form data when submitted
 */
export function showFooterForm() {
    return new Promise((resolve, reject) => {
        // Create form container
        const formContainer = document.createElement('div');
        formContainer.id = 'pdf-footer-form-container';
        
        // Add HTML content
        formContainer.innerHTML = createFormHTML();
        
        // Append to body
        document.body.appendChild(formContainer);
        
        // Load CSS dynamically
        loadFormCSS();
        
        // Get form elements
        const submitBtn = document.getElementById('form-submit');
        const cancelBtn = document.getElementById('form-cancel');
        
        // Handle submit
        submitBtn.addEventListener('click', () => {
            const formData = collectFormData();
            formContainer.remove();
            resolve(formData);
        });
        
        // Handle cancel
        cancelBtn.addEventListener('click', () => {
            formContainer.remove();
            reject(new Error('Form cancelled'));
        });
        
        // Handle escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                formContainer.remove();
                document.removeEventListener('keydown', handleEscape);
                reject(new Error('Form cancelled'));
            }
        };
        document.addEventListener('keydown', handleEscape);
    });
}

/**
 * Collect data from form inputs
 * @returns {Object} Form data object
 */
function collectFormData() {
    return {
        agent1: {
            name: document.getElementById('agent1-name').value.trim(),
            phone: document.getElementById('agent1-phone').value.trim(),
            email: document.getElementById('agent1-email').value.trim()
        },
        agent2: {
            name: document.getElementById('agent2-name').value.trim(),
            phone: document.getElementById('agent2-phone').value.trim(),
            email: document.getElementById('agent2-email').value.trim()
        },
        location: {
            name: document.getElementById('location-name').value.trim(),
            address: document.getElementById('location-address').value.trim()
        }
    };
}

/**
 * Load CSS file for the form
 */
function loadFormCSS() {
    // Check if CSS is already loaded
    if (document.getElementById('pdf-footer-form-css')) {
        return;
    }
    
    const link = document.createElement('link');
    link.id = 'pdf-footer-form-css';
    link.rel = 'stylesheet';
    link.href = '/js/user-analysis/pdf-export-folder/CSS/footer-form-styles.css';
    document.head.appendChild(link);
}

/**
 * Validate form data
 * @param {Object} formData - Form data to validate
 * @returns {Object} Validation result with isValid flag and errors array
 */
export function validateFormData(formData) {
    const errors = [];
    
    // Agent 1 is required
    if (!formData.agent1.name) {
        errors.push('Primary agent name is required');
    }
    
    // Email validation for agent 1 if provided
    if (formData.agent1.email && !isValidEmail(formData.agent1.email)) {
        errors.push('Primary agent email is invalid');
    }
    
    // Email validation for agent 2 if provided
    if (formData.agent2.email && !isValidEmail(formData.agent2.email)) {
        errors.push('Secondary agent email is invalid');
    }
    
    return {
        isValid: errors.length === 0,
        errors: errors
    };
}

/**
 * Validate email format
 * @param {string} email - Email to validate
 * @returns {boolean} True if valid
 */
function isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}





















js\user-analysis\pdf-export-folder\JS\pdf-export-main.js









// ==================== PDF EXPORT MAIN CONTROLLER ====================
// js/user-analysis/pdf-export-folder/JS/pdf-export-main.js

import { showFooterForm } from './footer-form-controller.js';
import { getCensusDataByRadius, getSampleCensusData } from './census-data-fetcher.js';
import { generatePDF } from './pdf-generator.js';

/**
 * Main PDF export function - called from UI
 * @param {HTMLCanvasElement} mapCanvas - Canvas element with map
 * @param {Object} selectedSiteLocation - Site location data
 */
export async function exportPDFEnhanced(mapCanvas, selectedSiteLocation) {
    try {
        // Get export button and update its state
        const exportBtn = document.querySelector('button[onclick="exportPDF()"]');
        if (exportBtn) {
            exportBtn.disabled = true;
            exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Fetching Census Data...';
        }
        
        // Fetch census data
        const lat = selectedSiteLocation.lat;
        const lng = selectedSiteLocation.lng;
        let censusResults;
        
        try {
            console.log('Fetching census data from API...');
            censusResults = await getCensusDataByRadius(lat, lng);
            console.log('✅ Census data fetched successfully');
        } catch (censusError) {
            console.error('Census API Error:', censusError);
            alert('Could not fetch census data: ' + censusError.message + '. Using sample data.');
            censusResults = getSampleCensusData();
        }
        
        // Update button state
        if (exportBtn) {
            exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Preparing PDF Export...';
        }
        
        // Show footer form and wait for user input
        try {
            const formData = await showFooterForm();
            console.log('Form data received:', formData);
            
            // Update button state
            if (exportBtn) {
                exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating PDF...';
            }
            
            // Generate PDF
            await generatePDF(censusResults, formData, mapCanvas, selectedSiteLocation);
            
            console.log('✅ PDF export complete');
            
        } catch (formError) {
            console.log('Form cancelled or error:', formError);
            // User cancelled - this is not an error
        }
        
        // Reset button state
        if (exportBtn) {
            exportBtn.disabled = false;
            exportBtn.innerHTML = '<i class="fas fa-file-pdf"></i> Export PDF';
        }
        
    } catch (error) {
        console.error('PDF export error:', error);
        alert('Error generating PDF: ' + (error.message || 'Unknown error'));
        
        // Reset button state
        const exportBtn = document.querySelector('button[onclick="exportPDF()"]');
        if (exportBtn) {
            exportBtn.disabled = false;
            exportBtn.innerHTML = '<i class="fas fa-file-pdf"></i> Export PDF';
        }
    }
}

/**
 * Setup global export function
 */
export function setupGlobalExportFunction(mapCanvas, selectedSiteLocation) {
    window.exportPDF = () => exportPDFEnhanced(mapCanvas, selectedSiteLocation);
}
















js\user-analysis\pdf-export-folder\JS\pdf-generator.js











// ==================== PDF GENERATOR MAIN ====================
// js/user-analysis/pdf-export-folder/JS/pdf-generator.js

import { addEnhancedHeader, addEnhancedFooter, addPageNumber } from './pdf-styles.js';
import { formatNumber, formatDecimal, formatCurrency } from './pdf-helpers.js';

/**
 * Generate complete PDF with census data
 * @param {Object} censusResults - Census data results
 * @param {Object} formData - Form data from footer form
 * @param {HTMLCanvasElement} mapCanvas - Canvas with map
 * @param {Object} selectedSiteLocation - Site location data
 */
export async function generatePDF(censusResults, formData, mapCanvas, selectedSiteLocation) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('landscape', 'mm', 'a4');
    const pageW = 297;
    const pageH = 210;
    const margin = 10;
    
    // Extract location name
    const locationName = selectedSiteLocation.address.split(',')[0].trim();
    
    // Get map image
    const mapDataUrl = mapCanvas.toDataURL('image/png', 1.0);
    
    // ==================== PAGE 1: FULL MAP ====================
    addEnhancedHeader(doc, pageW, 'Retailer Map');
    
    // Add full map
    const mapStartY = 20;
    const mapHeight = pageH - mapStartY - 35;
    doc.addImage(mapDataUrl, 'PNG', margin, mapStartY, pageW - (margin * 2), mapHeight);
    
    addEnhancedFooter(doc, pageW, pageH, formData.agent1, formData.agent2, formData.location);
    addPageNumber(doc, 1, 2, pageW, pageH);
    
    // ==================== PAGE 2: DEMOGRAPHIC REPORT ====================
    doc.addPage();
    addEnhancedHeader(doc, pageW, 'Demographic Analysis Report');
    
    // Add small overview map on right
    await addSmallOverviewMap(doc, pageW, pageH, selectedSiteLocation);
    
    // Add site location info
    addSiteLocationInfo(doc, margin, pageW, selectedSiteLocation);
    
    // Add demographic tables
    addPopulationTable(doc, margin, pageW, censusResults);
    addHouseholdTable(doc, margin, pageW, censusResults);
    
    // Add census disclaimer
    addCensusDisclaimer(doc, margin, pageW, pageH);
    
    addEnhancedFooter(doc, pageW, pageH, formData.agent1, formData.agent2, formData.location);
    addPageNumber(doc, 2, 2, pageW, pageH);
    
    // Save PDF
    const dateStr = new Date().toISOString().slice(0, 10);
    const fileName = `Retailer_Map_${locationName.replace(/[^a-z0-9]/gi, '_')}_${dateStr}.pdf`;
    doc.save(fileName);
    
    console.log('✅ PDF generated successfully');
}

/**
 * Add small overview map with radius circles
 */
async function addSmallOverviewMap(doc, pageW, pageH, selectedSiteLocation) {
    const smallMapWidth = (pageW - 20) * 0.35;
    const smallMapHeight = 65;
    const smallMapX = pageW - 10 - smallMapWidth;
    const smallMapY = 24;
    
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = 800;
    tempCanvas.height = 600;
    
    try {
        const lat = selectedSiteLocation.lat;
        const lng = selectedSiteLocation.lng;
        const radiusMeters = 5 * 1609.34;
        const latRad = lat * Math.PI / 180;
        const metersPerPixelAtZoom0 = 156543.03392 * Math.cos(latRad);
        const targetPixelsForRadius = 240;
        const calculatedZoom = Math.floor(Math.log2((metersPerPixelAtZoom0 * targetPixelsForRadius) / radiusMeters));
        
        // Draw map tiles
        await drawMapTiles(tempCtx, lat, lng, calculatedZoom);
        
        // Draw radius circles
        const metersPerPixel = metersPerPixelAtZoom0 / Math.pow(2, calculatedZoom);
        const radius1Mile = 1609.34 / metersPerPixel;
        const radius3Mile = 4828.03 / metersPerPixel;
        const radius5Mile = 8046.72 / metersPerPixel;
        
        tempCtx.strokeStyle = 'rgba(255, 0, 0, 0.85)';
        tempCtx.lineWidth = 4;
        [radius5Mile, radius3Mile, radius1Mile].forEach(r => {
            tempCtx.beginPath();
            tempCtx.arc(400, 300, r, 0, 2 * Math.PI);
            tempCtx.stroke();
        });
        
        // Draw site marker
        tempCtx.fillStyle = 'red';
        tempCtx.beginPath();
        tempCtx.arc(400, 300, 12, 0, 2 * Math.PI);
        tempCtx.fill();
        tempCtx.strokeStyle = 'white';
        tempCtx.lineWidth = 3;
        tempCtx.stroke();
        
        const smallMapDataUrl = tempCanvas.toDataURL('image/png', 1.0);
        doc.addImage(smallMapDataUrl, 'PNG', smallMapX, smallMapY, smallMapWidth, smallMapHeight);
        
        // Add decorative border
        doc.setDrawColor(139, 0, 0);
        doc.setLineWidth(1);
        doc.rect(smallMapX, smallMapY, smallMapWidth, smallMapHeight);
        
    } catch (error) {
        console.warn('Failed to generate overview map:', error);
        // Draw fallback placeholder
        tempCtx.fillStyle = '#f0f0f0';
        tempCtx.fillRect(0, 0, 800, 600);
        const fallbackUrl = tempCanvas.toDataURL('image/png', 1.0);
        doc.addImage(fallbackUrl, 'PNG', smallMapX, smallMapY, smallMapWidth, smallMapHeight);
    }
}

/**
 * Draw map tiles on canvas
 */
async function drawMapTiles(ctx, lat, lng, zoom) {
    const deg2tile = (lat, lon, zoom) => {
        const latRad = lat * Math.PI / 180;
        const n = Math.pow(2, zoom);
        return [
            ((lon + 180) / 360) * n,
            (1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n
        ];
    };
    
    const [centerTileX, centerTileY] = deg2tile(lat, lng, zoom);
    const startX = Math.floor(centerTileX - 2);
    const startY = Math.floor(centerTileY - 2);
    const endX = startX + 5;
    const endY = startY + 5;
    
    const tileCanvas = document.createElement('canvas');
    tileCanvas.width = 1280;
    tileCanvas.height = 1280;
    const tileCtx = tileCanvas.getContext('2d');
    
    const tilePromises = [];
    for (let x = startX; x < endX; x++) {
        for (let y = startY; y < endY; y++) {
            const tileUrl = `https://tile.openstreetmap.org/${zoom}/${x}/${y}.png`;
            tilePromises.push(new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    tileCtx.drawImage(img, (x - startX) * 256, (y - startY) * 256, 256, 256);
                    resolve();
                };
                img.onerror = () => resolve();
                img.src = tileUrl;
            }));
        }
    }
    await Promise.all(tilePromises);
    
    const sitePixelX = (centerTileX - startX) * 256;
    const sitePixelY = (centerTileY - startY) * 256;
    const offsetX = sitePixelX - 400;
    const offsetY = sitePixelY - 300;
    ctx.drawImage(tileCanvas, -offsetX, -offsetY);
}

/**
 * Add site location information box
 */
function addSiteLocationInfo(doc, margin, pageW, selectedSiteLocation) {
    const locationBoxWidth = (pageW - 20) * 0.6;
    let locationStartY = 29;
    
    // Section title
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(12);
    doc.setTextColor(139, 0, 0);
    doc.text('Site Location Information', margin + 5, locationStartY);
    
    // Info box background
    doc.setFillColor(240, 245, 255);
    doc.setDrawColor(139, 0, 0);
    doc.setLineWidth(0.5);
    doc.rect(margin + 5, locationStartY + 3, locationBoxWidth - 5, 15, 'FD');
    
    // Address details
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(10);
    doc.setTextColor(0, 0, 0);
    let locationY = locationStartY + 10;
    
    doc.setFont('helvetica', 'bold');
    doc.text('Address:', margin + 10, locationY);
    doc.setFont('helvetica', 'normal');
    const addressLines = doc.splitTextToSize(selectedSiteLocation.address, locationBoxWidth - 45);
    doc.text(addressLines, margin + 35, locationY);
}

/**
 * Add population and age table
 */
function addPopulationTable(doc, margin, pageW, censusResults) {
    const locationBoxWidth = (pageW - 20) * 0.6;
    let table1Y = 60;
    
    // Table title
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(11);
    doc.setTextColor(139, 0, 0);
    doc.text('Population & Age Demographics', margin + 5, table1Y);
    table1Y += 5;
    
    // Table header
    doc.setFillColor(139, 0, 0);
    doc.rect(margin + 5, table1Y, locationBoxWidth - 5, 8, 'F');
    
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(9);
    doc.setTextColor(255, 255, 255);
    
    const colMetric = margin + 8;
    const col1Mile = margin + 60;
    const col3Mile = margin + 80;
    const col5Mile = margin + 100;
    table1Y += 6;
    
    doc.text('Metric', colMetric, table1Y);
    doc.text('1 Mile', col1Mile, table1Y);
    doc.text('3 Mile', col3Mile, table1Y);
    doc.text('5 Mile', col5Mile, table1Y);
    
    // Table data
    const populationData = [
        { metric: 'Total Population', oneMile: formatNumber(censusResults['1_mile'].population), threeMile: formatNumber(censusResults['3_mile'].population), fiveMile: formatNumber(censusResults['5_mile'].population) },
        { metric: 'Avg Age', oneMile: formatDecimal(censusResults['1_mile'].avg_age), threeMile: formatDecimal(censusResults['3_mile'].avg_age), fiveMile: formatDecimal(censusResults['5_mile'].avg_age) },
        { metric: 'Avg Age (Male)', oneMile: formatDecimal(censusResults['1_mile'].avg_age_male), threeMile: formatDecimal(censusResults['3_mile'].avg_age_male), fiveMile: formatDecimal(censusResults['5_mile'].avg_age_male) },
        { metric: 'Avg Age (Female)', oneMile: formatDecimal(censusResults['1_mile'].avg_age_female), threeMile: formatDecimal(censusResults['3_mile'].avg_age_female), fiveMile: formatDecimal(censusResults['5_mile'].avg_age_female) }
    ];
    
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(8);
    doc.setTextColor(0, 0, 0);
    table1Y += 4;
    
    populationData.forEach((row, idx) => {
        doc.setFillColor(idx % 2 === 0 ? 240 : 255, idx % 2 === 0 ? 245 : 255, 255);
        doc.rect(margin + 5, table1Y - 3, locationBoxWidth - 5, 6, 'F');
        doc.setFont('helvetica', 'bold');
        doc.text(row.metric, colMetric, table1Y);
        doc.setFont('helvetica', 'normal');
        doc.text(row.oneMile, col1Mile, table1Y);
        doc.text(row.threeMile, col3Mile, table1Y);
        doc.text(row.fiveMile, col5Mile, table1Y);
        table1Y += 6;
    });
    
    doc.setDrawColor(150, 150, 150);
    doc.setLineWidth(0.3);
    doc.rect(margin + 5, 65, locationBoxWidth - 5, table1Y - 65);
}

/**
 * Add household and income table
 */
function addHouseholdTable(doc, margin, pageW, censusResults) {
    const locationBoxWidth = (pageW - 20) * 0.6;
    let table2Y = 105;  // Increased spacing from 95 to 105
    
    // Table title
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(11);
    doc.setTextColor(139, 0, 0);
    doc.text('Households & Income', margin + 5, table2Y);
    table2Y += 5;
    
    // Table header
    doc.setFillColor(139, 0, 0);
    doc.rect(margin + 5, table2Y, locationBoxWidth - 5, 8, 'F');
    
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(9);
    doc.setTextColor(255, 255, 255);
    
    const colMetric = margin + 8;
    const col1Mile = margin + 60;
    const col3Mile = margin + 80;
    const col5Mile = margin + 100;
    table2Y += 6;
    
    doc.text('Metric', colMetric, table2Y);
    doc.text('1 Mile', col1Mile, table2Y);
    doc.text('3 Mile', col3Mile, table2Y);
    doc.text('5 Mile', col5Mile, table2Y);
    
    // Table data
    const householdData = [
        { metric: 'Total Households', oneMile: formatNumber(censusResults['1_mile'].households), threeMile: formatNumber(censusResults['3_mile'].households), fiveMile: formatNumber(censusResults['5_mile'].households) },
        { metric: 'Persons per HH', oneMile: formatDecimal(censusResults['1_mile'].avg_hh_size), threeMile: formatDecimal(censusResults['3_mile'].avg_hh_size), fiveMile: formatDecimal(censusResults['5_mile'].avg_hh_size) },
        { metric: 'Avg HH Income', oneMile: formatCurrency(censusResults['1_mile'].avg_median_income), threeMile: formatCurrency(censusResults['3_mile'].avg_median_income), fiveMile: formatCurrency(censusResults['5_mile'].avg_median_income) },
        { metric: 'Avg Home Value', oneMile: formatCurrency(censusResults['1_mile'].avg_median_home_value), threeMile: formatCurrency(censusResults['3_mile'].avg_median_home_value), fiveMile: formatCurrency(censusResults['5_mile'].avg_median_home_value) }
    ];
    
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(8);
    doc.setTextColor(0, 0, 0);
    table2Y += 4;
    
    householdData.forEach((row, idx) => {
        doc.setFillColor(idx % 2 === 0 ? 240 : 255, idx % 2 === 0 ? 245 : 255, 255);
        doc.rect(margin + 5, table2Y - 3, locationBoxWidth - 5, 6, 'F');
        doc.setFont('helvetica', 'bold');
        doc.text(row.metric, colMetric, table2Y);
        doc.setFont('helvetica', 'normal');
        doc.text(row.oneMile, col1Mile, table2Y);
        doc.text(row.threeMile, col3Mile, table2Y);
        doc.text(row.fiveMile, col5Mile, table2Y);
        table2Y += 6;
    });
    
    doc.setDrawColor(150, 150, 150);
    doc.setLineWidth(0.3);
    doc.rect(margin + 5, 110, locationBoxWidth - 5, table2Y - 110);  // Updated Y position from 100 to 110
    
    // Add census disclaimer OUTSIDE the box
    const noteY = table2Y + 6;
    doc.setFont('helvetica', 'italic');
    doc.setFontSize(8);
    doc.setTextColor(100, 100, 100);
    doc.text('* Data derived from U.S. Census Bureau', margin + 5, noteY);
}

/**
 * Add census disclaimer
 */
function addCensusDisclaimer(doc, margin, pageW, pageH) {
    // This is now added inside addHouseholdTable function
    // Keeping this function for compatibility but it does nothing
}

















js\user-analysis\pdf-export-folder\JS\pdf-helpers.js







// ==================== PDF HELPER FUNCTIONS ====================
// js/user-analysis/pdf-export-folder/JS/pdf-helpers.js

/**
 * Format number with commas
 * @param {number} num - Number to format
 * @returns {string} Formatted number or 'N/A'
 */
export function formatNumber(num) {
    if (!num || isNaN(num)) return 'N/A';
    return Math.round(num).toLocaleString('en-US');
}

/**
 * Format number to decimal places
 * @param {number} num - Number to format
 * @param {number} decimals - Number of decimal places
 * @returns {string} Formatted decimal or 'N/A'
 */
export function formatDecimal(num, decimals = 1) {
    if (!num || isNaN(num)) return 'N/A';
    return num.toFixed(decimals);
}

/**
 * Format number as currency
 * @param {number} num - Number to format
 * @returns {string} Formatted currency or 'N/A'
 */
export function formatCurrency(num) {
    if (!num || isNaN(num)) return 'N/A';
    return '$' + Math.round(num).toLocaleString('en-US');
}

/**
 * Calculate distance between two coordinates
 * @param {number} lat1 - Latitude 1
 * @param {number} lon1 - Longitude 1
 * @param {number} lat2 - Latitude 2
 * @param {number} lon2 - Longitude 2
 * @returns {number} Distance in miles
 */
export function getDistanceInMiles(lat1, lon1, lat2, lon2) {
    const R = 3958.8; // Earth radius in miles
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

/**
 * Aggregate census data for multiple tracts
 * @param {Array} geoidList - List of geoid strings
 * @param {Map} dataMap - Map of tract data
 * @returns {Object} Aggregated data
 */
export function aggregateData(geoidList, dataMap) {
    let totalPop = 0, totalMale = 0, totalFemale = 0, totalHouseholds = 0, totalOwners = 0;
    let weightedIncomeSum = 0, weightedHomeValueSum = 0, weightedAgeSum = 0;
    let weightedAgeMaleSum = 0, weightedAgeFemaleSum = 0, weightedHHSizeSum = 0;
    let ageCount = 0, ageMaleCount = 0, ageFemaleCount = 0, hhSizeCount = 0;
    
    geoidList.forEach(geoid => {
        const d = dataMap.get(geoid);
        if (d) {
            totalPop += d.pop;
            totalMale += d.male;
            totalFemale += d.female;
            totalHouseholds += d.households;
            totalOwners += d.owners;
            
            if (d.income > 0) weightedIncomeSum += (d.income * d.households);
            if (d.homeValue > 0) weightedHomeValueSum += (d.homeValue * d.owners);
            
            if (d.medianAge > 0 && d.pop > 0) {
                weightedAgeSum += (d.medianAge * d.pop);
                ageCount += d.pop;
            }
            if (d.medianAgeMale > 0 && d.male > 0) {
                weightedAgeMaleSum += (d.medianAgeMale * d.male);
                ageMaleCount += d.male;
            }
            if (d.medianAgeFemale > 0 && d.female > 0) {
                weightedAgeFemaleSum += (d.medianAgeFemale * d.female);
                ageFemaleCount += d.female;
            }
            if (d.avgHHSize > 0 && d.households > 0) {
                weightedHHSizeSum += (d.avgHHSize * d.households);
                hhSizeCount += d.households;
            }
        }
    });
    
    return {
        population: totalPop,
        male: totalMale,
        female: totalFemale,
        households: totalHouseholds,
        avg_median_income: totalHouseholds > 0 ? Math.round(weightedIncomeSum / totalHouseholds) : 0,
        avg_median_home_value: totalOwners > 0 ? Math.round(weightedHomeValueSum / totalOwners) : 0,
        avg_age: ageCount > 0 ? (weightedAgeSum / ageCount) : 0,
        avg_age_male: ageMaleCount > 0 ? (weightedAgeMaleSum / ageMaleCount) : 0,
        avg_age_female: ageFemaleCount > 0 ? (weightedAgeFemaleSum / ageFemaleCount) : 0,
        avg_hh_size: hhSizeCount > 0 ? (weightedHHSizeSum / hhSizeCount) : 0
    };
}















js\user-analysis\pdf-export-folder\JS\pdf-styles.js













// ==================== PDF STYLING FUNCTIONS ====================
// js/user-analysis/pdf-export-folder/JS/pdf-styles.js

/**
 * Add enhanced header to PDF page
 * @param {jsPDF} doc - jsPDF document instance
 * @param {number} pageWidth - Page width
 * @param {string} title - Header title
 * @param {string} subtitle - Optional subtitle
 */
export function addEnhancedHeader(doc, pageWidth, title, subtitle = null) {
    const margin = 10;
    
    // Simple solid background
    doc.setFillColor(139, 0, 0);
    doc.rect(0, 0, pageWidth, 18, 'F');
    
    // Main title
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(18);
    doc.setTextColor(255, 255, 255);
    doc.text(title, pageWidth / 2, 12, { align: 'center' });
    
    // Reset text color
    doc.setTextColor(0, 0, 0);
}

/**
 * Add enhanced footer to PDF page
 * @param {jsPDF} doc - jsPDF document instance
 * @param {number} pageWidth - Page width
 * @param {number} pageHeight - Page height
 * @param {Object} agent1 - Agent 1 data
 * @param {Object} agent2 - Agent 2 data
 * @param {Object} location - Location data
 */
export function addEnhancedFooter(doc, pageWidth, pageHeight, agent1, agent2, location) {
    const margin = 10;
    const footerStartY = pageHeight - 22;
    
    // Simple top line separator
    doc.setDrawColor(100, 100, 100);
    doc.setLineWidth(0.3);
    doc.line(margin, footerStartY - 5, pageWidth - margin, footerStartY - 5);
    
    // Agent 1 Section
    if (agent1.name) {
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(9);
        doc.setTextColor(40, 40, 40);
        doc.text(agent1.name, margin, footerStartY + 1);
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(8);
        doc.setTextColor(80, 80, 80);
        if (agent1.phone) doc.text(`Office Number: ${agent1.phone}`, margin, footerStartY + 5);
        if (agent1.email) doc.text(`Email: ${agent1.email}`, margin, footerStartY + 8);
    }
    
    // Agent 2 Section (middle)
    if (agent2.name) {
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(9);
        doc.setTextColor(40, 40, 40);
        doc.text(agent2.name, pageWidth / 2 - 20, footerStartY + 1);
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(8);
        doc.setTextColor(80, 80, 80);
        if (agent2.phone) doc.text(`Office Number: ${agent2.phone}`, pageWidth / 2 - 20, footerStartY + 5);
        if (agent2.email) doc.text(`Email: ${agent2.email}`, pageWidth / 2 - 20, footerStartY + 8);
    }
    
    // Location Section (right)
    if (location.name) {
        doc.setLineWidth(0.2);
        doc.line(pageWidth - 85, footerStartY - 4, pageWidth - 85, footerStartY + 10);
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(9);
        doc.setTextColor(40, 40, 40);
        doc.text(location.name, pageWidth - 75, footerStartY + 1);
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(8);
        doc.setTextColor(80, 80, 80);
        if (location.address) {
            const addressLines = doc.splitTextToSize(location.address, 70);
            doc.text(addressLines, pageWidth - 75, footerStartY + 5);
        }
    }
    
    // Add company logo in bottom right corner
    addFooterLogo(doc, pageWidth, footerStartY);
}

/**
 * Add company logo to footer
 */
function addFooterLogo(doc, pageWidth, footerStartY) {
    const logoImg = document.getElementById('pdfLogo');
    if (logoImg && logoImg.complete) {
        const maxLogoWidth = 25;
        const maxLogoHeight = 10;
        const imgAspect = logoImg.naturalWidth / logoImg.naturalHeight;
        
        let logoWidth = maxLogoWidth;
        let logoHeight = maxLogoWidth / imgAspect;
        
        if (logoHeight > maxLogoHeight) {
            logoHeight = maxLogoHeight;
            logoWidth = maxLogoHeight * imgAspect;
        }
        
        const margin = 10;
        doc.addImage(logoImg, 'PNG', pageWidth - logoWidth - margin, footerStartY + 10, logoWidth, logoHeight);
    }
}

/**
 * Add page number to footer
 */
export function addPageNumber(doc, pageNum, totalPages, pageWidth, pageHeight) {
    doc.setFont('helvetica', 'italic');
    doc.setFontSize(8);
    doc.setTextColor(100, 100, 100);
    doc.text(
        `Page ${pageNum} of ${totalPages}`,
        pageWidth / 2,
        pageHeight - 5,
        { align: 'center' }
    );
}












